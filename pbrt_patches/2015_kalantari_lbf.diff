diff -uarN 2015_kalantari_lbf/compile_commands.json ../methods/2015_kalantari_lbf/compile_commands.json
--- 2015_kalantari_lbf/compile_commands.json	1969-12-31 16:00:00.000000000 -0800
+++ ../methods/2015_kalantari_lbf/compile_commands.json	2019-09-11 11:26:25.572201673 -0700
@@ -0,0 +1,29 @@
+[
+    {
+        "arguments": [
+            "c++", 
+            "-c", 
+            "-fopenmp", 
+            "-O2", 
+            "-std=c++11", 
+            "-m64", 
+            "-march=native", 
+            "-I.", 
+            "-Icore", 
+            "-I/usr/local/include/OpenEXR", 
+            "-I/usr/include/OpenEXR", 
+            "-I/usr/local/include", 
+            "-I/opt/local/include", 
+            "-I/usr/local/cuda/include", 
+            "-Wall", 
+            "-DPBRT_HAS_OPENEXR", 
+            "-DNDEBUG", 
+            "-DPBRT_PROBES_NONE", 
+            "-o", 
+            "objs/LBF_LBF.o", 
+            "LBF/LBF.cpp"
+        ], 
+        "directory": "/home/gharbi/rendernet_comparisons/2015_kalantari_lbf_win/pbrt-v2-lbf/src", 
+        "file": "LBF/LBF.cpp"
+    }
+]
\ No newline at end of file
diff -uarN 2015_kalantari_lbf/core/api.cpp ../methods/2015_kalantari_lbf/core/api.cpp
--- 2015_kalantari_lbf/core/api.cpp	2015-05-20 13:05:42.000000000 -0700
+++ ../methods/2015_kalantari_lbf/core/api.cpp	2019-09-11 11:26:25.572201673 -0700
@@ -1261,7 +1261,7 @@
     //}
     //else {
 	if(RendererName == "metropolis" || RendererName == "createprobes" || RendererName == "aggregatetest" || RendererName == "surfacepoints") {
-		printf("\n%s renderer ignored. Switching to SamplerRenderer\n\n", RendererName);
+		printf("\n%s renderer ignored. Switching to SamplerRenderer\n\n", RendererName.c_str());
 	}
  /*   if (RendererName != "sampler")
         Warning("Renderer type \"%s\" unknown.  Using \"sampler\".",
diff -uarN 2015_kalantari_lbf/core/diffgeom.cpp ../methods/2015_kalantari_lbf/core/diffgeom.cpp
--- 2015_kalantari_lbf/core/diffgeom.cpp	2013-07-09 07:53:44.000000000 -0700
+++ ../methods/2015_kalantari_lbf/core/diffgeom.cpp	2019-09-11 11:26:25.572201673 -0700
@@ -64,11 +64,11 @@
         float d = -Dot(nn, Vector(p.x, p.y, p.z));
         Vector rxv(ray.rxOrigin.x, ray.rxOrigin.y, ray.rxOrigin.z);
         float tx = -(Dot(nn, rxv) + d) / Dot(nn, ray.rxDirection);
-        if (isnan(tx)) goto fail;
+        if (std::isnan(tx)) goto fail;
         Point px = ray.rxOrigin + tx * ray.rxDirection;
         Vector ryv(ray.ryOrigin.x, ray.ryOrigin.y, ray.ryOrigin.z);
         float ty = -(Dot(nn, ryv) + d) / Dot(nn, ray.ryDirection);
-        if (isnan(ty)) goto fail;
+        if (std::isnan(ty)) goto fail;
         Point py = ray.ryOrigin + ty * ray.ryDirection;
         dpdx = px - p;
         dpdy = py - p;
diff -uarN 2015_kalantari_lbf/core/geometry.h ../methods/2015_kalantari_lbf/core/geometry.h
--- 2015_kalantari_lbf/core/geometry.h	2014-12-25 18:26:06.000000000 -0800
+++ ../methods/2015_kalantari_lbf/core/geometry.h	2019-09-11 11:26:25.576201709 -0700
@@ -48,7 +48,7 @@
         : x(xx), y(yy), z(zz) {
         Assert(!HasNaNs());
     }
-    bool HasNaNs() const { return isnan(x) || isnan(y) || isnan(z); }
+    bool HasNaNs() const { return std::isnan(x) || std::isnan(y) || std::isnan(z); }
     explicit Vector(const Point &p);
 #ifndef NDEBUG
     // The default versions of these are fine for release builds; for debug
@@ -87,7 +87,7 @@
     Vector operator*(float f) const { return Vector(f*x, f*y, f*z); }
     
     Vector &operator*=(float f) {
-        Assert(!isnan(f));
+        Assert(!std::isnan(f));
         x *= f; y *= f; z *= f;
         return *this;
     }
@@ -209,7 +209,7 @@
         return (&x)[i];
     }
     bool HasNaNs() const {
-        return isnan(x) || isnan(y) || isnan(z);
+        return std::isnan(x) || std::isnan(y) || std::isnan(z);
     }
 
     bool operator==(const Point &p) const {
@@ -256,7 +256,7 @@
         return *this;
     }
     bool HasNaNs() const {
-        return isnan(x) || isnan(y) || isnan(z);
+        return std::isnan(x) || std::isnan(y) || std::isnan(z);
     }
     Normal operator*(float f) const {
         return Normal(f*x, f*y, f*z);
@@ -333,7 +333,7 @@
     Point operator()(float t) const { return o + d * t; }
     bool HasNaNs() const {
         return (o.HasNaNs() || d.HasNaNs() ||
-                isnan(mint) || isnan(maxt));
+                std::isnan(mint) || std::isnan(maxt));
     }
 
     // Ray Public Data
diff -uarN 2015_kalantari_lbf/core/integrator.cpp ../methods/2015_kalantari_lbf/core/integrator.cpp
--- 2015_kalantari_lbf/core/integrator.cpp	2015-04-06 16:47:08.000000000 -0700
+++ ../methods/2015_kalantari_lbf/core/integrator.cpp	2019-09-11 11:26:25.576201709 -0700
@@ -36,7 +36,7 @@
 #include "scene.h"
 #include "intersection.h"
 #include "montecarlo.h"
-#include "../SampleWriter/SampleWriter.h" // MOD
+#include "SampleWriter/SampleWriter.h" // MOD
 
 // Integrator Method Definitions
 Integrator::~Integrator() {
diff -uarN 2015_kalantari_lbf/core/pbrtlex.cpp ../methods/2015_kalantari_lbf/core/pbrtlex.cpp
--- 2015_kalantari_lbf/core/pbrtlex.cpp	2013-07-09 07:53:44.000000000 -0700
+++ ../methods/2015_kalantari_lbf/core/pbrtlex.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,2378 +0,0 @@
-#line 2 "core/pbrtlex.cpp"
-
-#line 4 "core/pbrtlex.cpp"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 35
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-#endif /* ! C99 */
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#endif /* ! FLEXINT_H */
-
-#ifdef __cplusplus
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-/* C99 requires __STDC__ to be defined as 1. */
-#if defined (__STDC__)
-
-#define YY_USE_CONST
-
-#endif	/* defined (__STDC__) */
-#endif	/* ! __cplusplus */
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN (yy_start) = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START (((yy_start) - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart(yyin  )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#define YY_BUF_SIZE 16384
-#endif
-
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-extern yy_size_t yyleng;
-
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-    #define YY_LESS_LINENO(n)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = (yy_hold_char); \
-		YY_RESTORE_YY_MORE_OFFSET \
-		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, (yytext_ptr)  )
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	yy_size_t yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-    
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* Stack of input buffers. */
-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
-                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
-
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
-yy_size_t yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 0;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart (FILE *input_file  );
-void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
-void yy_delete_buffer (YY_BUFFER_STATE b  );
-void yy_flush_buffer (YY_BUFFER_STATE b  );
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state (void );
-
-static void yyensure_buffer_stack (void );
-static void yy_load_buffer_state (void );
-static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
-
-#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
-
-YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
-
-void *yyalloc (yy_size_t  );
-void *yyrealloc (void *,yy_size_t  );
-void yyfree (void *  );
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
-
-/* Begin user sect3 */
-
-typedef unsigned char YY_CHAR;
-
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-
-typedef int yy_state_type;
-
-extern int yylineno;
-
-int yylineno = 1;
-
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state (void );
-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
-static int yy_get_next_buffer (void );
-static void yy_fatal_error (yyconst char msg[]  );
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	(yytext_ptr) = yy_bp; \
-	yyleng = (size_t) (yy_cp - yy_bp); \
-	(yy_hold_char) = *yy_cp; \
-	*yy_cp = '\0'; \
-	(yy_c_buf_p) = yy_cp;
-
-#define YY_NUM_RULES 66
-#define YY_END_OF_BUFFER 67
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static yyconst flex_int16_t yy_accept[394] =
-    {   0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-       67,   65,   45,   46,   51,    1,   65,   65,   47,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   49,   50,   63,   64,   62,
-       63,    2,    3,   66,   45,    0,   47,   47,   47,    0,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   61,   60,
-       57,   61,   58,   55,   56,   52,   54,   53,   47,    0,
-       47,   48,   48,    6,   48,   48,   48,   48,   48,   48,
-
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,    0,   48,   48,   48,   48,   48,   48,   48,
-       48,   15,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   59,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   31,   32,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   10,   48,   48,
-       48,   48,   48,   48,   48,   19,   48,   48,   48,   48,
-
-       48,   48,   48,   29,   48,   48,   48,   48,   48,   48,
-       41,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       14,   48,   17,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   30,   48,   48,   35,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   16,
-       48,   48,   21,   48,   48,   48,   48,   48,   27,   48,
-       48,   48,   48,   48,   48,   48,   44,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   24,   48,
-       48,   48,   33,   48,   39,   40,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-
-       48,   48,   48,   48,   48,   48,   48,   48,   43,    4,
-       48,   48,   48,   48,   48,   48,   48,   18,   48,   48,
-       23,   48,   26,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,    9,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   37,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   22,   48,   48,   48,   48,   48,   48,   48,
-       48,    8,   48,   48,   48,   48,   25,   48,   48,   36,
-       38,   48,    5,    7,   11,   48,   48,   48,   48,   48,
-       48,   48,   12,   48,   48,   48,   42,   13,   20,   48,
-       34,   28,    0
-
-    } ;
-
-static yyconst flex_int32_t yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    1,    4,    5,    1,    1,    1,    1,    1,
-        1,    1,    6,    1,    6,    7,    1,    8,    8,    8,
-        8,    8,    8,    8,    8,    8,    8,    1,    1,    1,
-        1,    1,    1,    1,    9,   10,   11,   12,   13,   14,
-       12,   12,   15,   12,   12,   16,   17,   18,   19,   20,
-       12,   21,   22,   23,   12,   24,   25,   12,   12,   12,
-       26,   27,   28,    1,   12,    1,   29,   30,   31,   32,
-
-       33,   34,   35,   36,   37,   38,   39,   40,   41,   42,
-       43,   44,   12,   45,   46,   47,   48,   49,   12,   50,
-       51,   12,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst flex_int32_t yy_meta[52] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    2,    2,    2,
-        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
-        2,    2,    2,    2,    2,    1,    1,    1,    2,    2,
-        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
-        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
-        2
-    } ;
-
-static yyconst flex_int16_t yy_base[399] =
-    {   0,
-        0,    0,   49,   51,  430,  429,    0,    0,    0,    0,
-      431,  434,  428,  434,  434,  434,   49,  421,   51,   30,
-        0,   31,  386,  390,   30,   26,  397,  396,  394,  386,
-       38,   51,   34,  379,  378,  434,  434,  434,  434,  434,
-       97,  434,  434,  434,  418,  411,   78,   60,   75,   84,
-        0,   63,  378,  384,  369,  374,   23,  382,  373,  379,
-      380,  375,  366,   50,  367,  369,  356,   53,  358,  363,
-      374,  373,  372,  355,  349,  369,  357,  351,  434,  434,
-      434,  387,  434,  434,  434,  434,  434,  434,   96,  386,
-      385,  359,  354,    0,  361,  344,  355,  356,  341,  362,
-
-      343,  341,  342,  345,  341,  346,  345,  344,  343,  342,
-      342,  340,  343,  327,  330,  325,  323,  333,  319,  323,
-      316,  323,  354,  321,  311,  343,  321,  312,  327,  323,
-      317,    0,  306,  304,  304,  341,  331,  303,  315,  315,
-      305,  311,  298,  295,  301,  307,  306,  291,  308,  288,
-      289,  293,  301,  434,  299,  298,  293,  299,  299,  280,
-       81,  285,  288,  292,  301,  275,  292,  283,  302,  271,
-      303,  271,  269,  281,  280,    0,    0,  289,  280,  265,
-       72,  276,  103,  263,  284,  271,  257,    0,  281,  252,
-      260,  268,  253,  266,  255,    0,  256,  267,  266,  104,
-
-      257,  260,  259,    0,  246,  253,  256,  255,  244,  257,
-      270,  251,  241,  253,  236,  244,  232,  233,  231,  247,
-        0,  224,    0,  226,  240,  232,  224,  237,  227,  226,
-      227,  221,  246,    0,  223,  248,    0,  217,  214,  218,
-      224,  226,  210,  227,  208,  221,  224,  229,  204,    0,
-      205,  217,    0,  215,  212,  214,  199,  197,    0,  198,
-      209,  199,  199,  206,  191,  200,    0,  193,  193,  212,
-      110,  191,  187,  198,  199,  212,  183,  190,    0,  179,
-      192,  187,    0,  176,  112,    0,  189,  179,  175,  173,
-      175,  184,  174,  169,  185,  191,  179,  182,  173,  167,
-
-      179,  162,  173,  172,  171,  161,  165,  166,    0,    0,
-      166,  151,  163,  165,  162,  153,  143,    0,  146,  163,
-        0,  149,    0,  148,  154,  153,  155,  145,  140,  141,
-      138,  145,    0,  138,  134,  133,  145,  137,  145,  128,
-      129,  136,    0,  139,  142,  125,  138,  126,  122,  132,
-      118,  119,    0,  130,  133,  132,  118,  113,  111,  116,
-      123,    0,  114,  111,  120,  106,    0,   94,   93,    0,
-        0,   95,    0,    0,    0,   92,   95,  105,   96,   89,
-       85,   87,    0,   86,   78,   70,    0,    0,    0,   65,
-        0,    0,  434,  144,  146,  148,   94,  150
-
-    } ;
-
-static yyconst flex_int16_t yy_def[399] =
-    {   0,
-      393,    1,  394,  394,  395,  395,  396,  396,  396,  396,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  393,  393,  393,  393,  393,
-      398,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  393,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  393,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,    0,  393,  393,  393,  393,  393
-
-    } ;
-
-static yyconst flex_int16_t yy_nxt[486] =
-    {   0,
-       12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
-       22,   21,   23,   24,   25,   26,   27,   28,   29,   30,
-       31,   32,   33,   34,   35,   36,   12,   37,   21,   21,
-       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
-       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
-       21,   39,   40,   39,   40,   46,   47,   49,   47,   56,
-       52,   60,   62,   50,   98,   99,   75,   48,   63,   53,
-       68,   61,   50,   57,   54,   41,   55,   41,   76,   70,
-       69,   71,   89,   50,   49,   47,   72,   50,  106,   90,
-       50,   91,   50,   92,  111,   51,  107,   73,   74,   80,
-
-       81,  112,  190,   89,   82,  209,  392,   50,   50,   93,
-       50,  210,  212,  228,  391,  213,  229,  191,  230,  292,
-      390,  305,  293,   83,  306,  389,   84,  388,   50,  387,
-       85,  386,  385,  384,  307,  383,  382,  381,   86,  380,
-      379,   87,  378,   88,   38,   38,   42,   42,   44,   44,
-       79,   79,  377,  376,  375,  374,  373,  372,  371,  370,
-      369,  368,  367,  366,  365,  364,  363,  362,  361,  360,
-      359,  358,  357,  356,  355,  354,  353,  352,  351,  350,
-      349,  348,  347,  346,  345,  344,  343,  342,  341,  340,
-      339,  338,  337,  336,  335,  334,  333,  332,  331,  330,
-
-      329,  328,  327,  326,  325,  324,  323,  322,  321,  320,
-      319,  318,  317,  316,  315,  314,  313,  312,  311,  310,
-      309,  308,  304,  303,  302,  301,  300,  299,  298,  297,
-      296,  295,  294,  291,  290,  289,  288,  287,  286,  285,
-      284,  283,  282,  281,  280,  279,  278,  277,  276,  275,
-      274,  273,  272,  271,  270,  269,  268,  267,  266,  265,
-      264,  263,  262,  261,  260,  259,  258,  257,  256,  255,
-      254,  253,  252,  251,  250,  249,  248,  247,  246,  245,
-      244,  243,  242,  241,  240,  239,  238,  237,  236,  235,
-      234,  233,  232,  231,  227,  226,  225,  224,  223,  222,
-
-      221,  220,  219,  218,  217,  216,  215,  214,  211,  208,
-      207,  206,  205,  204,  203,  202,  201,  200,  199,  198,
-      197,  196,  195,  194,  193,  192,  189,  188,  187,  186,
-      185,  184,  183,  182,  181,  180,  179,  178,  177,  176,
-      175,  174,  173,  172,  171,  170,  169,  168,  167,  166,
-      165,  164,  163,  162,  161,  160,  159,  158,  157,  156,
-      155,  154,  153,  152,  151,  150,  149,  148,  147,  146,
-      145,  144,  143,  142,  141,  140,  139,  138,  137,  136,
-      135,  134,  133,  132,  131,  130,  129,  128,  127,  126,
-      125,  124,   91,   91,  123,  122,  121,  120,  119,  118,
-
-      117,  116,  115,  114,  113,  110,  109,  108,  105,  104,
-      103,  102,  101,  100,   97,   96,   95,   94,   48,   45,
-       78,   77,   67,   66,   65,   64,   59,   58,   48,   45,
-      393,   43,   43,   11,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393
-    } ;
-
-static yyconst flex_int16_t yy_chk[486] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    3,    3,    4,    4,   17,   17,   19,   19,   22,
-       20,   25,   26,   19,   57,   57,   33,   48,   26,   20,
-       31,   25,   48,   22,   20,    3,   20,    4,   33,   32,
-       31,   32,   49,   19,   47,   47,   32,   49,   64,   50,
-       47,   50,   48,   52,   68,  397,   64,   32,   32,   41,
-
-       41,   68,  161,   89,   41,  181,  390,   49,   89,   52,
-       47,  181,  183,  200,  386,  183,  200,  161,  200,  271,
-      385,  285,  271,   41,  285,  384,   41,  382,   89,  381,
-       41,  380,  379,  378,  285,  377,  376,  372,   41,  369,
-      368,   41,  366,   41,  394,  394,  395,  395,  396,  396,
-      398,  398,  365,  364,  363,  361,  360,  359,  358,  357,
-      356,  355,  354,  352,  351,  350,  349,  348,  347,  346,
-      345,  344,  342,  341,  340,  339,  338,  337,  336,  335,
-      334,  332,  331,  330,  329,  328,  327,  326,  325,  324,
-      322,  320,  319,  317,  316,  315,  314,  313,  312,  311,
-
-      308,  307,  306,  305,  304,  303,  302,  301,  300,  299,
-      298,  297,  296,  295,  294,  293,  292,  291,  290,  289,
-      288,  287,  284,  282,  281,  280,  278,  277,  276,  275,
-      274,  273,  272,  270,  269,  268,  266,  265,  264,  263,
-      262,  261,  260,  258,  257,  256,  255,  254,  252,  251,
-      249,  248,  247,  246,  245,  244,  243,  242,  241,  240,
-      239,  238,  236,  235,  233,  232,  231,  230,  229,  228,
-      227,  226,  225,  224,  222,  220,  219,  218,  217,  216,
-      215,  214,  213,  212,  211,  210,  209,  208,  207,  206,
-      205,  203,  202,  201,  199,  198,  197,  195,  194,  193,
-
-      192,  191,  190,  189,  187,  186,  185,  184,  182,  180,
-      179,  178,  175,  174,  173,  172,  171,  170,  169,  168,
-      167,  166,  165,  164,  163,  162,  160,  159,  158,  157,
-      156,  155,  153,  152,  151,  150,  149,  148,  147,  146,
-      145,  144,  143,  142,  141,  140,  139,  138,  137,  136,
-      135,  134,  133,  131,  130,  129,  128,  127,  126,  125,
-      124,  123,  122,  121,  120,  119,  118,  117,  116,  115,
-      114,  113,  112,  111,  110,  109,  108,  107,  106,  105,
-      104,  103,  102,  101,  100,   99,   98,   97,   96,   95,
-       93,   92,   91,   90,   82,   78,   77,   76,   75,   74,
-
-       73,   72,   71,   70,   69,   67,   66,   65,   63,   62,
-       61,   60,   59,   58,   56,   55,   54,   53,   46,   45,
-       35,   34,   30,   29,   28,   27,   24,   23,   18,   13,
-       11,    6,    5,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-extern int yy_flex_debug;
-int yy_flex_debug = 0;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "core/pbrtlex.ll"
-/*
-    pbrt source code Copyright(c) 1998-2010 Matt Pharr and Greg Humphreys.
-
-    This file is part of pbrt.
-
-    Redistribution and use in source and binary forms, with or without
-    modification, are permitted provided that the following conditions are
-    met:
-
-    - Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-
-    - Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-
-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
- */
-/* state used for include file stuff */
-#line 26 "core/pbrtlex.ll"
-
-#define YY_MAIN 0
-#define YY_NEVER_INTERACTIVE 1
-
-#include "pbrt.h"
-#include "api.h"
-#include "fileutil.h"
-
-struct ParamArray;
-
-#if defined(PBRT_IS_WINDOWS)
-#pragma warning(disable:4244)
-#pragma warning(disable:4065)
-#pragma warning(disable:4018)
-#pragma warning(disable:4996)
-#endif
-#include "pbrtparse.hh"
-
-struct IncludeInfo {
-    string filename;
-    YY_BUFFER_STATE bufState;
-    int lineNum;
-};
-
-
-vector<IncludeInfo> includeStack;
-
-extern int line_num;
-int str_pos;
-
-void add_string_char(char c) {
-    yylval.string[str_pos++] = c;
-    yylval.string[str_pos] = '\0';
-}
-
-
-void include_push(char *filename) {
-    if (includeStack.size() > 32)
-        Severe("Only 32 levels of nested Include allowed in scene files.");
-    IncludeInfo ii;
-    extern string current_file;
-    ii.filename = current_file;
-    ii.bufState = YY_CURRENT_BUFFER;
-    ii.lineNum = line_num;
-    includeStack.push_back(ii);
-
-    current_file = AbsolutePath(ResolveFilename(filename));
-    line_num = 1;
-
-    yyin = fopen(current_file.c_str(), "r");
-    if (!yyin)
-        Severe("Unable to open included scene file \"%s\"", current_file.c_str());
-    yy_switch_to_buffer(yy_create_buffer(yyin,YY_BUF_SIZE));
-}
-
-
-
-void include_pop() {
-    extern int line_num;
-    extern string current_file;
-    fclose(yyin);
-    yy_delete_buffer(YY_CURRENT_BUFFER);
-    yy_switch_to_buffer(includeStack.back().bufState);
-    current_file = includeStack.back().filename;
-    line_num = includeStack.back().lineNum;
-    includeStack.pop_back();
-}
-
-
-
-#line 781 "core/pbrtlex.cpp"
-
-#define INITIAL 0
-#define STR 1
-#define COMMENT 2
-#define INCL 3
-#define INCL_FILE 4
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-static int yy_init_globals (void );
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy (void );
-
-int yyget_debug (void );
-
-void yyset_debug (int debug_flag  );
-
-YY_EXTRA_TYPE yyget_extra (void );
-
-void yyset_extra (YY_EXTRA_TYPE user_defined  );
-
-FILE *yyget_in (void );
-
-void yyset_in  (FILE * in_str  );
-
-FILE *yyget_out (void );
-
-void yyset_out  (FILE * out_str  );
-
-yy_size_t yyget_leng (void );
-
-char *yyget_text (void );
-
-int yyget_lineno (void );
-
-void yyset_lineno (int line_number  );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap (void );
-#else
-extern int yywrap (void );
-#endif
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int );
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * );
-#endif
-
-#ifndef YY_NO_INPUT
-
-#ifdef __cplusplus
-static int yyinput (void );
-#else
-static int input (void );
-#endif
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		yy_size_t n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* end tables serialization structures and prototypes */
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex (void);
-
-#define YY_DECL int yylex (void)
-#endif /* !YY_DECL */
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
-    
-#line 101 "core/pbrtlex.ll"
-
-
-#line 968 "core/pbrtlex.cpp"
-
-	if ( !(yy_init) )
-		{
-		(yy_init) = 1;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! (yy_start) )
-			(yy_start) = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			yyensure_buffer_stack ();
-			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer(yyin,YY_BUF_SIZE );
-		}
-
-		yy_load_buffer_state( );
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = (yy_c_buf_p);
-
-		/* Support of yytext. */
-		*yy_cp = (yy_hold_char);
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = (yy_start);
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				(yy_last_accepting_state) = yy_current_state;
-				(yy_last_accepting_cpos) = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 394 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 434 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = (yy_hold_char);
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 103 "core/pbrtlex.ll"
-{ BEGIN COMMENT; }
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 104 "core/pbrtlex.ll"
-/* eat it up */
-	YY_BREAK
-case 3:
-/* rule 3 can match eol */
-YY_RULE_SETUP
-#line 105 "core/pbrtlex.ll"
-{ line_num++; BEGIN INITIAL; }
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 106 "core/pbrtlex.ll"
-{ return ACCELERATOR; }
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 107 "core/pbrtlex.ll"
-{ return ACTIVETRANSFORM; }
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 108 "core/pbrtlex.ll"
-{ return ALL; }
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 109 "core/pbrtlex.ll"
-{ return AREALIGHTSOURCE; }
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 110 "core/pbrtlex.ll"
-{ return ATTRIBUTEBEGIN; }
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 111 "core/pbrtlex.ll"
-{ return ATTRIBUTEEND; }
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 112 "core/pbrtlex.ll"
-{ return CAMERA; }
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 113 "core/pbrtlex.ll"
-{ return CONCATTRANSFORM; }
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 114 "core/pbrtlex.ll"
-{ return COORDINATESYSTEM; }
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 115 "core/pbrtlex.ll"
-{ return COORDSYSTRANSFORM; }
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 116 "core/pbrtlex.ll"
-{ return ENDTIME; }
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 117 "core/pbrtlex.ll"
-{ return FILM; }
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 118 "core/pbrtlex.ll"
-{ return IDENTITY; }
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 119 "core/pbrtlex.ll"
-{ return INCLUDE; }
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 120 "core/pbrtlex.ll"
-{ return LIGHTSOURCE; }
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 121 "core/pbrtlex.ll"
-{ return LOOKAT; }
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 122 "core/pbrtlex.ll"
-{ return MAKENAMEDMATERIAL; }
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 123 "core/pbrtlex.ll"
-{ return MATERIAL; }
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 124 "core/pbrtlex.ll"
-{ return NAMEDMATERIAL; }
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 125 "core/pbrtlex.ll"
-{ return OBJECTBEGIN; }
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 126 "core/pbrtlex.ll"
-{ return OBJECTEND; }
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 127 "core/pbrtlex.ll"
-{ return OBJECTINSTANCE; }
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 128 "core/pbrtlex.ll"
-{ return PIXELFILTER; }
-	YY_BREAK
-case 27:
-YY_RULE_SETUP
-#line 129 "core/pbrtlex.ll"
-{ return RENDERER; }
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 130 "core/pbrtlex.ll"
-{ return REVERSEORIENTATION; }
-	YY_BREAK
-case 29:
-YY_RULE_SETUP
-#line 131 "core/pbrtlex.ll"
-{ return ROTATE; }
-	YY_BREAK
-case 30:
-YY_RULE_SETUP
-#line 132 "core/pbrtlex.ll"
-{ return SAMPLER; }
-	YY_BREAK
-case 31:
-YY_RULE_SETUP
-#line 133 "core/pbrtlex.ll"
-{ return SCALE; }
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 134 "core/pbrtlex.ll"
-{ return SHAPE; }
-	YY_BREAK
-case 33:
-YY_RULE_SETUP
-#line 135 "core/pbrtlex.ll"
-{ return STARTTIME; }
-	YY_BREAK
-case 34:
-YY_RULE_SETUP
-#line 136 "core/pbrtlex.ll"
-{ return SURFACEINTEGRATOR; }
-	YY_BREAK
-case 35:
-YY_RULE_SETUP
-#line 137 "core/pbrtlex.ll"
-{ return TEXTURE; }
-	YY_BREAK
-case 36:
-YY_RULE_SETUP
-#line 138 "core/pbrtlex.ll"
-{ return TRANSFORMBEGIN; }
-	YY_BREAK
-case 37:
-YY_RULE_SETUP
-#line 139 "core/pbrtlex.ll"
-{ return TRANSFORMEND; }
-	YY_BREAK
-case 38:
-YY_RULE_SETUP
-#line 140 "core/pbrtlex.ll"
-{ return TRANSFORMTIMES; }
-	YY_BREAK
-case 39:
-YY_RULE_SETUP
-#line 141 "core/pbrtlex.ll"
-{ return TRANSFORM; }
-	YY_BREAK
-case 40:
-YY_RULE_SETUP
-#line 142 "core/pbrtlex.ll"
-{ return TRANSLATE; }
-	YY_BREAK
-case 41:
-YY_RULE_SETUP
-#line 143 "core/pbrtlex.ll"
-{ return VOLUME; }
-	YY_BREAK
-case 42:
-YY_RULE_SETUP
-#line 144 "core/pbrtlex.ll"
-{ return VOLUMEINTEGRATOR; }
-	YY_BREAK
-case 43:
-YY_RULE_SETUP
-#line 145 "core/pbrtlex.ll"
-{ return WORLDBEGIN; }
-	YY_BREAK
-case 44:
-YY_RULE_SETUP
-#line 146 "core/pbrtlex.ll"
-{ return WORLDEND; }
-	YY_BREAK
-case 45:
-YY_RULE_SETUP
-#line 147 "core/pbrtlex.ll"
-/* do nothing */
-	YY_BREAK
-case 46:
-/* rule 46 can match eol */
-YY_RULE_SETUP
-#line 148 "core/pbrtlex.ll"
-{ line_num++; }
-	YY_BREAK
-case 47:
-YY_RULE_SETUP
-#line 149 "core/pbrtlex.ll"
-{
-    yylval.num = (float) atof(yytext);
-    return NUM;
-}
-	YY_BREAK
-case 48:
-YY_RULE_SETUP
-#line 155 "core/pbrtlex.ll"
-{
-    strcpy(yylval.string, yytext);
-    return ID;
-}
-	YY_BREAK
-case 49:
-YY_RULE_SETUP
-#line 161 "core/pbrtlex.ll"
-{ return LBRACK; }
-	YY_BREAK
-case 50:
-YY_RULE_SETUP
-#line 162 "core/pbrtlex.ll"
-{ return RBRACK; }
-	YY_BREAK
-case 51:
-YY_RULE_SETUP
-#line 163 "core/pbrtlex.ll"
-{ BEGIN STR; str_pos = 0; }
-	YY_BREAK
-case 52:
-YY_RULE_SETUP
-#line 164 "core/pbrtlex.ll"
-{add_string_char('\n');}
-	YY_BREAK
-case 53:
-YY_RULE_SETUP
-#line 165 "core/pbrtlex.ll"
-{add_string_char('\t');}
-	YY_BREAK
-case 54:
-YY_RULE_SETUP
-#line 166 "core/pbrtlex.ll"
-{add_string_char('\r');}
-	YY_BREAK
-case 55:
-YY_RULE_SETUP
-#line 167 "core/pbrtlex.ll"
-{add_string_char('\b');}
-	YY_BREAK
-case 56:
-YY_RULE_SETUP
-#line 168 "core/pbrtlex.ll"
-{add_string_char('\f');}
-	YY_BREAK
-case 57:
-YY_RULE_SETUP
-#line 169 "core/pbrtlex.ll"
-{add_string_char('\"');}
-	YY_BREAK
-case 58:
-YY_RULE_SETUP
-#line 170 "core/pbrtlex.ll"
-{add_string_char('\\');}
-	YY_BREAK
-case 59:
-YY_RULE_SETUP
-#line 171 "core/pbrtlex.ll"
-{
-  int val = atoi(yytext+1);
-  while (val > 256)
-    val -= 256;
-  add_string_char(val);
-}
-	YY_BREAK
-case 60:
-/* rule 60 can match eol */
-YY_RULE_SETUP
-#line 179 "core/pbrtlex.ll"
-{line_num++;}
-	YY_BREAK
-case 61:
-YY_RULE_SETUP
-#line 180 "core/pbrtlex.ll"
-{ add_string_char(yytext[1]);}
-	YY_BREAK
-case 62:
-YY_RULE_SETUP
-#line 181 "core/pbrtlex.ll"
-{BEGIN INITIAL; return STRING;}
-	YY_BREAK
-case 63:
-YY_RULE_SETUP
-#line 182 "core/pbrtlex.ll"
-{add_string_char(yytext[0]);}
-	YY_BREAK
-case 64:
-/* rule 64 can match eol */
-YY_RULE_SETUP
-#line 183 "core/pbrtlex.ll"
-{Error("Unterminated string!");}
-	YY_BREAK
-case 65:
-YY_RULE_SETUP
-#line 185 "core/pbrtlex.ll"
-{ Error( "Illegal character: %c (0x%x)", yytext[0], int(yytext[0])); }
-	YY_BREAK
-case 66:
-YY_RULE_SETUP
-#line 186 "core/pbrtlex.ll"
-ECHO;
-	YY_BREAK
-#line 1396 "core/pbrtlex.cpp"
-case YY_STATE_EOF(INITIAL):
-case YY_STATE_EOF(STR):
-case YY_STATE_EOF(COMMENT):
-case YY_STATE_EOF(INCL):
-case YY_STATE_EOF(INCL_FILE):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = (yy_hold_char);
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state(  );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++(yy_c_buf_p);
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = (yy_c_buf_p);
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer(  ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				(yy_did_buffer_switch_on_eof) = 0;
-
-				if ( yywrap( ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				(yy_c_buf_p) =
-					(yytext_ptr) + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				(yy_c_buf_p) =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-} /* end of yylex */
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (void)
-{
-    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	register char *source = (yytext_ptr);
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
-
-	else
-		{
-			yy_size_t num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
-
-			int yy_c_buf_p_offset =
-				(int) ((yy_c_buf_p) - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				yy_size_t new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
-						number_to_move - 1;
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			(yy_n_chars), num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	if ( (yy_n_chars) == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart(yyin  );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
-		/* Extend the array by 50%, plus the number we really need. */
-		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
-		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
-	}
-
-	(yy_n_chars) += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
-
-	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
-
-	return ret_val;
-}
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-    static yy_state_type yy_get_previous_state (void)
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-    
-	yy_current_state = (yy_start);
-
-	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			(yy_last_accepting_state) = yy_current_state;
-			(yy_last_accepting_cpos) = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 394 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-}
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
-{
-	register int yy_is_jam;
-    	register char *yy_cp = (yy_c_buf_p);
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		(yy_last_accepting_state) = yy_current_state;
-		(yy_last_accepting_cpos) = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 394 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 393);
-
-	return yy_is_jam ? 0 : yy_current_state;
-}
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (void)
-#else
-    static int input  (void)
-#endif
-
-{
-	int c;
-    
-	*(yy_c_buf_p) = (yy_hold_char);
-
-	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			/* This was really a NUL. */
-			*(yy_c_buf_p) = '\0';
-
-		else
-			{ /* need more input */
-			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
-			++(yy_c_buf_p);
-
-			switch ( yy_get_next_buffer(  ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart(yyin );
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap( ) )
-						return 0;
-
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					(yy_c_buf_p) = (yytext_ptr) + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
-	*(yy_c_buf_p) = '\0';	/* preserve yytext */
-	(yy_hold_char) = *++(yy_c_buf_p);
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
-
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * 
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void yyrestart  (FILE * input_file )
-{
-    
-	if ( ! YY_CURRENT_BUFFER ){
-        yyensure_buffer_stack ();
-		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer(yyin,YY_BUF_SIZE );
-	}
-
-	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
-	yy_load_buffer_state( );
-}
-
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * 
- */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
-{
-    
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		yypop_buffer_state();
-	 *		yypush_buffer_state(new_buffer);
-     */
-	yyensure_buffer_stack ();
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-static void yy_load_buffer_state  (void)
-{
-    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	(yy_hold_char) = *(yy_c_buf_p);
-}
-
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * 
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer(b,file );
-
-	return b;
-}
-
-/** Destroy the buffer.
- * @param b a buffer created with yy_create_buffer()
- * 
- */
-    void yy_delete_buffer (YY_BUFFER_STATE  b )
-{
-    
-	if ( ! b )
-		return;
-
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yyfree((void *) b->yy_ch_buf  );
-
-	yyfree((void *) b  );
-}
-
-#ifndef __cplusplus
-extern int isatty (int );
-#endif /* __cplusplus */
-    
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a yyrestart() or at EOF.
- */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
-
-{
-	int oerrno = errno;
-    
-	yy_flush_buffer(b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-    /* If b is the current buffer, then yy_init_buffer was _probably_
-     * called from yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
-
-        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-    
-	errno = oerrno;
-}
-
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * 
- */
-    void yy_flush_buffer (YY_BUFFER_STATE  b )
-{
-    	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( );
-}
-
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  
- */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
-{
-    	if (new_buffer == NULL)
-		return;
-
-	yyensure_buffer_stack();
-
-	/* This block is copied from yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		(yy_buffer_stack_top)++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( );
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  
- */
-void yypop_buffer_state (void)
-{
-    	if (!YY_CURRENT_BUFFER)
-		return;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if ((yy_buffer_stack_top) > 0)
-		--(yy_buffer_stack_top);
-
-	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( );
-		(yy_did_buffer_switch_on_eof) = 1;
-	}
-}
-
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void yyensure_buffer_stack (void)
-{
-	yy_size_t num_to_alloc;
-    
-	if (!(yy_buffer_stack)) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
-         */
-		num_to_alloc = 1;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-								  
-		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
-		(yy_buffer_stack_max) = num_to_alloc;
-		(yy_buffer_stack_top) = 0;
-		return;
-	}
-
-	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		int grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = (yy_buffer_stack_max) + grow_size;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
-								((yy_buffer_stack),
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		/* zero only the new slots.*/
-		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
-		(yy_buffer_stack_max) = num_to_alloc;
-	}
-}
-
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object. 
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer(b  );
-
-	return b;
-}
-
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * 
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
-{
-    
-	return yy_scan_bytes(yystr,strlen(yystr) );
-}
-
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n, i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = _yybytes_len + 2;
-	buf = (char *) yyalloc(n  );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
-
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer(buf,n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-}
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-static void yy_fatal_error (yyconst char* msg )
-{
-    	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = (yy_hold_char); \
-		(yy_c_buf_p) = yytext + yyless_macro_arg; \
-		(yy_hold_char) = *(yy_c_buf_p); \
-		*(yy_c_buf_p) = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
-
-/** Get the current line number.
- * 
- */
-int yyget_lineno  (void)
-{
-        
-    return yylineno;
-}
-
-/** Get the input stream.
- * 
- */
-FILE *yyget_in  (void)
-{
-        return yyin;
-}
-
-/** Get the output stream.
- * 
- */
-FILE *yyget_out  (void)
-{
-        return yyout;
-}
-
-/** Get the length of the current token.
- * 
- */
-yy_size_t yyget_leng  (void)
-{
-        return yyleng;
-}
-
-/** Get the current token.
- * 
- */
-
-char *yyget_text  (void)
-{
-        return yytext;
-}
-
-/** Set the current line number.
- * @param line_number
- * 
- */
-void yyset_lineno (int  line_number )
-{
-    
-    yylineno = line_number;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param in_str A readable stream.
- * 
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  in_str )
-{
-        yyin = in_str ;
-}
-
-void yyset_out (FILE *  out_str )
-{
-        yyout = out_str ;
-}
-
-int yyget_debug  (void)
-{
-        return yy_flex_debug;
-}
-
-void yyset_debug (int  bdebug )
-{
-        yy_flex_debug = bdebug ;
-}
-
-static int yy_init_globals (void)
-{
-        /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    (yy_buffer_stack) = 0;
-    (yy_buffer_stack_top) = 0;
-    (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = (char *) 0;
-    (yy_init) = 0;
-    (yy_start) = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = (FILE *) 0;
-    yyout = (FILE *) 0;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (void)
-{
-    
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer(YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		yypop_buffer_state();
-	}
-
-	/* Destroy the stack itself. */
-	yyfree((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
-
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( );
-
-    return 0;
-}
-
-/*
- * Internal utility routines.
- */
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
-{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * s )
-{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-}
-#endif
-
-void *yyalloc (yy_size_t  size )
-{
-	return (void *) malloc( size );
-}
-
-void *yyrealloc  (void * ptr, yy_size_t  size )
-{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-}
-
-void yyfree (void * ptr )
-{
-	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
-}
-
-#define YYTABLES_NAME "yytables"
-
-#line 186 "core/pbrtlex.ll"
-
-
-int yywrap() {
-    if (includeStack.size() == 0) return 1;
-    include_pop();
-    return 0;
-}
-
-
-
-
diff -uarN 2015_kalantari_lbf/core/pbrtparse.cpp ../methods/2015_kalantari_lbf/core/pbrtparse.cpp
--- 2015_kalantari_lbf/core/pbrtparse.cpp	2013-07-09 07:53:44.000000000 -0700
+++ ../methods/2015_kalantari_lbf/core/pbrtparse.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,2683 +0,0 @@
-/* A Bison parser, made by GNU Bison 2.5.  */
-
-/* Bison implementation for Yacc-like parsers in C
-   
-      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
-   
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* As a special exception, you may create a larger work that contains
-   part or all of the Bison parser skeleton and distribute that work
-   under terms of your choice, so long as that work isn't itself a
-   parser generator using the skeleton or a modified version thereof
-   as a parser skeleton.  Alternatively, if you modify or redistribute
-   the parser skeleton itself, you may (at your option) remove this
-   special exception, which will cause the skeleton and the resulting
-   Bison output files to be licensed under the GNU General Public
-   License without this special exception.
-   
-   This special exception was added by the Free Software Foundation in
-   version 2.2 of Bison.  */
-
-/* C LALR(1) parser skeleton written by Richard Stallman, by
-   simplifying the original so-called "semantic" parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Bison version.  */
-#define YYBISON_VERSION "2.5"
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Push parsers.  */
-#define YYPUSH 0
-
-/* Pull parsers.  */
-#define YYPULL 1
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Copy the first part of user declarations.  */
-
-/* Line 268 of yacc.c  */
-#line 24 "core/pbrtparse.yy"
-
-#include "api.h"
-#include "pbrt.h"
-#include "paramset.h"
-#include <stdarg.h>
-
-#ifdef PBRT_IS_WINDOWS
-#pragma warning(disable:4065)
-#pragma warning(disable:4996)
-#pragma warning(disable:4018)
-#endif // PBRT_IS_WINDOWS
-
-extern int yylex();
-extern void include_push(char *filename);
-int line_num = 0;
-string current_file;
-
-#define YYMAXDEPTH 100000000
-
-void yyerror(const char *str) {
-    Severe("Parsing error: %s", str);
-}
-
-
-
-struct ParamArray {
-    ParamArray() {
-        isString = false;
-        element_size = allocated = nelems = 0;
-        array = NULL;
-    }
-    bool isString;
-    int element_size;
-    int allocated;
-    int nelems;
-    void *array;
-};
-
-
-
-struct ParamListItem {
-    ParamListItem(const char *t, ParamArray *array) {
-        arg = array->array;
-        name = t;
-        size = array->nelems;
-        isString = array->isString;
-        array->allocated = 0;
-        array->nelems = 0;
-        array->array = NULL;
-    }
-    const char *name;
-    void *arg;
-    int size;
-    bool isString;
-};
-
-
-
-static vector<ParamListItem> cur_paramlist;
-
-static ParamArray *cur_array = NULL;
-
-static void AddArrayElement(void *elem) {
-    if (cur_array->nelems >= cur_array->allocated) {
-        cur_array->allocated = 2*cur_array->allocated + 1;
-        cur_array->array = realloc(cur_array->array,
-            cur_array->allocated*cur_array->element_size);
-    }
-    char *next = ((char *)cur_array->array) + cur_array->nelems * cur_array->element_size;
-    Assert(cur_array->element_size == 4 || cur_array->element_size == 8);
-    if (cur_array->element_size == 4)
-        *((uint32_t *)next) = *((uint32_t *)elem);
-    else
-        *((uint64_t *)next) = *((uint64_t *)elem);
-    cur_array->nelems++;
-}
-
-
-
-static void ArrayFree(ParamArray *ra) {
-    if (ra->isString && ra->array)
-        for (int i = 0; i < ra->nelems; ++i) free(((char **)ra->array)[i]);
-    free(ra->array);
-    delete ra;
-}
-
-
-
-static void FreeArgs() {
-    for (uint32_t i = 0; i < cur_paramlist.size(); ++i)
-        free((char *)cur_paramlist[i].arg);
-    cur_paramlist.erase(cur_paramlist.begin(), cur_paramlist.end());
-}
-
-
-
-static bool VerifyArrayLength(ParamArray *arr, int required,
-    const char *command) {
-    if (arr->nelems != required) {
-        Error("\"%s\" requires a %d element array! (%d found)",
-                    command, required, arr->nelems);
-        return false;
-    }
-    return true;
-}
-
-
-enum { PARAM_TYPE_INT, PARAM_TYPE_BOOL, PARAM_TYPE_FLOAT, PARAM_TYPE_POINT,
-    PARAM_TYPE_VECTOR, PARAM_TYPE_NORMAL, PARAM_TYPE_RGB, PARAM_TYPE_XYZ,
-    PARAM_TYPE_BLACKBODY, PARAM_TYPE_SPECTRUM,
-    PARAM_TYPE_STRING, PARAM_TYPE_TEXTURE };
-static const char *paramTypeToName(int type);
-static void InitParamSet(ParamSet &ps, SpectrumType);
-static bool lookupType(const char *name, int *type, string &sname);
-#define YYPRINT(file, type, value)  { \
-    if ((type) == ID || (type) == STRING) \
-        fprintf ((file), " %s", (value).string); \
-    else if ((type) == NUM) \
-        fprintf ((file), " %f", (value).num); \
-}
-
-
-
-
-/* Line 268 of yacc.c  */
-#line 196 "core/pbrtparse.cpp"
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 1
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     STRING = 258,
-     ID = 259,
-     NUM = 260,
-     LBRACK = 261,
-     RBRACK = 262,
-     ACCELERATOR = 263,
-     ACTIVETRANSFORM = 264,
-     ALL = 265,
-     AREALIGHTSOURCE = 266,
-     ATTRIBUTEBEGIN = 267,
-     ATTRIBUTEEND = 268,
-     CAMERA = 269,
-     CONCATTRANSFORM = 270,
-     COORDINATESYSTEM = 271,
-     COORDSYSTRANSFORM = 272,
-     ENDTIME = 273,
-     FILM = 274,
-     IDENTITY = 275,
-     INCLUDE = 276,
-     LIGHTSOURCE = 277,
-     LOOKAT = 278,
-     MAKENAMEDMATERIAL = 279,
-     MATERIAL = 280,
-     NAMEDMATERIAL = 281,
-     OBJECTBEGIN = 282,
-     OBJECTEND = 283,
-     OBJECTINSTANCE = 284,
-     PIXELFILTER = 285,
-     RENDERER = 286,
-     REVERSEORIENTATION = 287,
-     ROTATE = 288,
-     SAMPLER = 289,
-     SCALE = 290,
-     SHAPE = 291,
-     STARTTIME = 292,
-     SURFACEINTEGRATOR = 293,
-     TEXTURE = 294,
-     TRANSFORMBEGIN = 295,
-     TRANSFORMEND = 296,
-     TRANSFORMTIMES = 297,
-     TRANSFORM = 298,
-     TRANSLATE = 299,
-     VOLUME = 300,
-     VOLUMEINTEGRATOR = 301,
-     WORLDBEGIN = 302,
-     WORLDEND = 303,
-     HIGH_PRECEDENCE = 304
-   };
-#endif
-
-
-
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef union YYSTYPE
-{
-
-/* Line 301 of yacc.c  */
-#line 148 "core/pbrtparse.yy"
-
-char string[1024];
-float num;
-ParamArray *ribarray;
-
-
-
-/* Line 301 of yacc.c  */
-#line 289 "core/pbrtparse.cpp"
-} YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-#endif
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 343 of yacc.c  */
-#line 301 "core/pbrtparse.cpp"
-
-#ifdef short
-# undef short
-#endif
-
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
-#endif
-
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
-#elif (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-typedef signed char yytype_int8;
-#else
-typedef short int yytype_int8;
-#endif
-
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
-#else
-typedef unsigned short int yytype_uint16;
-#endif
-
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
-#else
-typedef short int yytype_int16;
-#endif
-
-#ifndef YYSIZE_T
-# ifdef __SIZE_TYPE__
-#  define YYSIZE_T __SIZE_TYPE__
-# elif defined size_t
-#  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# else
-#  define YYSIZE_T unsigned int
-# endif
-#endif
-
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
-
-#ifndef YY_
-# if defined YYENABLE_NLS && YYENABLE_NLS
-#  if ENABLE_NLS
-#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
-#   define YY_(msgid) dgettext ("bison-runtime", msgid)
-#  endif
-# endif
-# ifndef YY_
-#  define YY_(msgid) msgid
-# endif
-#endif
-
-/* Suppress unused-variable warnings by "using" E.  */
-#if ! defined lint || defined __GNUC__
-# define YYUSE(e) ((void) (e))
-#else
-# define YYUSE(e) /* empty */
-#endif
-
-/* Identity function, used to suppress warnings about constant conditions.  */
-#ifndef lint
-# define YYID(n) (n)
-#else
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static int
-YYID (int yyi)
-#else
-static int
-YYID (yyi)
-    int yyi;
-#endif
-{
-  return yyi;
-}
-#endif
-
-#if ! defined yyoverflow || YYERROR_VERBOSE
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   elif defined __BUILTIN_VA_ARG_INCR
-#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
-#   elif defined _AIX
-#    define YYSTACK_ALLOC __alloca
-#   elif defined _MSC_VER
-#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
-#    define alloca _alloca
-#   else
-#    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     ifndef EXIT_SUCCESS
-#      define EXIT_SUCCESS 0
-#     endif
-#    endif
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning.  */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-    /* The OS might guarantee only one guard page at the bottom of the stack,
-       and a page size can be as small as 4096 bytes.  So we cannot safely
-       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
-       to allow for a few compiler-allocated temporary stack slots.  */
-#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
-#  endif
-# else
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
-#  endif
-#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
-       && ! ((defined YYMALLOC || defined malloc) \
-	     && (defined YYFREE || defined free)))
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef EXIT_SUCCESS
-#    define EXIT_SUCCESS 0
-#   endif
-#  endif
-#  ifndef YYMALLOC
-#   define YYMALLOC malloc
-#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-#  ifndef YYFREE
-#   define YYFREE free
-#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-void free (void *); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-# endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
-
-
-#if (! defined yyoverflow \
-     && (! defined __cplusplus \
-	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  yytype_int16 yyss_alloc;
-  YYSTYPE yyvs_alloc;
-};
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
-      + YYSTACK_GAP_MAXIMUM)
-
-# define YYCOPY_NEEDED 1
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
-	Stack = &yyptr->Stack_alloc;					\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (YYID (0))
-
-#endif
-
-#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined __GNUC__ && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  YYSIZE_T yyi;				\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (YYID (0))
-#  endif
-# endif
-#endif /* !YYCOPY_NEEDED */
-
-/* YYFINAL -- State number of the termination state.  */
-#define YYFINAL  75
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   118
-
-/* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  50
-/* YYNNTS -- Number of nonterminals.  */
-#define YYNNTS  20
-/* YYNRULES -- Number of rules.  */
-#define YYNRULES  66
-/* YYNRULES -- Number of states.  */
-#define YYNSTATES  136
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   304
-
-#define YYTRANSLATE(YYX)						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const yytype_uint8 yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
-      45,    46,    47,    48,    49
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const yytype_uint8 yyprhs[] =
-{
-       0,     0,     3,     5,     6,     7,     8,    10,    12,    17,
-      19,    22,    25,    27,    30,    35,    37,    40,    43,    45,
-      48,    51,    52,    55,    56,    59,    62,    64,    68,    71,
-      74,    77,    81,    83,    85,    89,    92,    95,    98,   102,
-     104,   107,   111,   122,   126,   130,   133,   136,   138,   141,
-     145,   149,   151,   157,   161,   166,   170,   174,   180,   182,
-     184,   188,   191,   196,   200,   204,   206
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
-static const yytype_int8 yyrhs[] =
-{
-      51,     0,    -1,    68,    -1,    -1,    -1,    -1,    56,    -1,
-      60,    -1,    52,     6,    58,     7,    -1,    57,    -1,    52,
-      59,    -1,    58,    59,    -1,    59,    -1,    53,     3,    -1,
-      52,     6,    62,     7,    -1,    61,    -1,    52,    63,    -1,
-      62,    63,    -1,    63,    -1,    54,     5,    -1,    65,    66,
-      -1,    -1,    67,    66,    -1,    -1,     3,    55,    -1,    68,
-      69,    -1,    69,    -1,     8,     3,    64,    -1,     9,    10,
-      -1,     9,    18,    -1,     9,    37,    -1,    11,     3,    64,
-      -1,    12,    -1,    13,    -1,    14,     3,    64,    -1,    15,
-      60,    -1,    16,     3,    -1,    17,     3,    -1,    19,     3,
-      64,    -1,    20,    -1,    21,     3,    -1,    22,     3,    64,
-      -1,    23,     5,     5,     5,     5,     5,     5,     5,     5,
-       5,    -1,    24,     3,    64,    -1,    25,     3,    64,    -1,
-      26,     3,    -1,    27,     3,    -1,    28,    -1,    29,     3,
-      -1,    30,     3,    64,    -1,    31,     3,    64,    -1,    32,
-      -1,    33,     5,     5,     5,     5,    -1,    34,     3,    64,
-      -1,    35,     5,     5,     5,    -1,    36,     3,    64,    -1,
-      38,     3,    64,    -1,    39,     3,     3,     3,    64,    -1,
-      40,    -1,    41,    -1,    42,     5,     5,    -1,    43,    60,
-      -1,    44,     5,     5,     5,    -1,    46,     3,    64,    -1,
-      45,     3,    64,    -1,    47,    -1,    48,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const yytype_uint16 yyrline[] =
-{
-       0,   171,   171,   177,   185,   193,   201,   207,   214,   221,
-     229,   235,   240,   246,   254,   261,   269,   275,   280,   286,
-     294,   300,   313,   319,   324,   332,   337,   343,   352,   358,
-     364,   370,   379,   385,   391,   400,   408,   414,   420,   429,
-     435,   441,   450,   456,   465,   474,   480,   486,   492,   498,
-     507,   516,   522,   528,   537,   543,   552,   561,   570,   576,
-     582,   588,   596,   602,   611,   620,   626
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
-/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "STRING", "ID", "NUM", "LBRACK",
-  "RBRACK", "ACCELERATOR", "ACTIVETRANSFORM", "ALL", "AREALIGHTSOURCE",
-  "ATTRIBUTEBEGIN", "ATTRIBUTEEND", "CAMERA", "CONCATTRANSFORM",
-  "COORDINATESYSTEM", "COORDSYSTRANSFORM", "ENDTIME", "FILM", "IDENTITY",
-  "INCLUDE", "LIGHTSOURCE", "LOOKAT", "MAKENAMEDMATERIAL", "MATERIAL",
-  "NAMEDMATERIAL", "OBJECTBEGIN", "OBJECTEND", "OBJECTINSTANCE",
-  "PIXELFILTER", "RENDERER", "REVERSEORIENTATION", "ROTATE", "SAMPLER",
-  "SCALE", "SHAPE", "STARTTIME", "SURFACEINTEGRATOR", "TEXTURE",
-  "TRANSFORMBEGIN", "TRANSFORMEND", "TRANSFORMTIMES", "TRANSFORM",
-  "TRANSLATE", "VOLUME", "VOLUMEINTEGRATOR", "WORLDBEGIN", "WORLDEND",
-  "HIGH_PRECEDENCE", "$accept", "start", "array_init", "string_array_init",
-  "num_array_init", "array", "string_array", "single_element_string_array",
-  "string_list", "string_list_entry", "num_array",
-  "single_element_num_array", "num_list", "num_list_entry", "paramlist",
-  "paramlist_init", "paramlist_contents", "paramlist_entry",
-  "pbrt_stmt_list", "pbrt_stmt", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const yytype_uint16 yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
-     295,   296,   297,   298,   299,   300,   301,   302,   303,   304
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint8 yyr1[] =
-{
-       0,    50,    51,    52,    53,    54,    55,    55,    56,    56,
-      57,    58,    58,    59,    60,    60,    61,    62,    62,    63,
-      64,    65,    66,    66,    67,    68,    68,    69,    69,    69,
-      69,    69,    69,    69,    69,    69,    69,    69,    69,    69,
-      69,    69,    69,    69,    69,    69,    69,    69,    69,    69,
-      69,    69,    69,    69,    69,    69,    69,    69,    69,    69,
-      69,    69,    69,    69,    69,    69,    69
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
-{
-       0,     2,     1,     0,     0,     0,     1,     1,     4,     1,
-       2,     2,     1,     2,     4,     1,     2,     2,     1,     2,
-       2,     0,     2,     0,     2,     2,     1,     3,     2,     2,
-       2,     3,     1,     1,     3,     2,     2,     2,     3,     1,
-       2,     3,    10,     3,     3,     2,     2,     1,     2,     3,
-       3,     1,     5,     3,     4,     3,     3,     5,     1,     1,
-       3,     2,     4,     3,     3,     1,     1
-};
-
-/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
-   Performed when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const yytype_uint8 yydefact[] =
-{
-       0,     0,     0,     0,    32,    33,     0,     3,     0,     0,
-       0,    39,     0,     0,     0,     0,     0,     0,     0,    47,
-       0,     0,     0,    51,     0,     0,     0,     0,     0,     0,
-      58,    59,     0,     3,     0,     0,     0,    65,    66,     0,
-       2,    26,    21,    28,    29,    30,    21,    21,     5,    35,
-      15,    36,    37,    21,    40,    21,     0,    21,    21,    45,
-      46,    48,    21,    21,     0,    21,     0,    21,    21,     0,
-       0,    61,     0,    21,    21,     1,    25,    27,    23,    31,
-      34,     5,     0,    16,    38,    41,     0,    43,    44,    49,
-      50,     0,    53,     0,    55,    56,     0,    60,     0,    64,
-      63,     3,    20,    23,     5,    18,    19,     0,     0,    54,
-      21,    62,     4,    24,     6,     9,     7,    22,    14,    17,
-       0,    52,    57,     4,     0,    10,     0,     4,    12,    13,
-       0,     8,    11,     0,     0,    42
-};
-
-/* YYDEFGOTO[NTERM-NUM].  */
-static const yytype_int8 yydefgoto[] =
-{
-      -1,    39,    48,   124,    82,   113,   114,   115,   127,   125,
-      49,    50,   104,    83,    77,    78,   102,   103,    40,    41
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -119
-static const yytype_int8 yypact[] =
-{
-      58,     1,    -4,     4,  -119,  -119,     8,  -119,    16,    18,
-      21,  -119,    22,    24,    25,    28,    29,    31,    32,  -119,
-      33,    34,    35,  -119,    36,    37,    38,    39,    41,    43,
-    -119,  -119,    42,  -119,    44,    45,    47,  -119,  -119,    51,
-      58,  -119,  -119,  -119,  -119,  -119,  -119,  -119,    46,  -119,
-    -119,  -119,  -119,  -119,  -119,  -119,    48,  -119,  -119,  -119,
-    -119,  -119,  -119,  -119,    49,  -119,    50,  -119,  -119,    53,
-      52,  -119,    54,  -119,  -119,  -119,  -119,  -119,    55,  -119,
-    -119,  -119,    56,  -119,  -119,  -119,    57,  -119,  -119,  -119,
-    -119,    59,  -119,    71,  -119,  -119,    60,  -119,    90,  -119,
-    -119,  -119,  -119,    55,   100,  -119,  -119,   103,   104,  -119,
-    -119,  -119,    10,  -119,  -119,  -119,  -119,  -119,  -119,  -119,
-     105,  -119,  -119,   106,   109,  -119,   108,   107,  -119,  -119,
-     110,  -119,  -119,   111,   112,  -119
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yytype_int8 yypgoto[] =
-{
-    -119,  -119,   -62,  -119,  -119,  -119,  -119,  -119,  -119,  -118,
-     -33,  -119,  -119,   -78,   -45,  -119,   -43,  -119,  -119,    78
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -6
-static const yytype_int16 yytable[] =
-{
-      71,    79,    80,   105,    42,   128,    43,    46,    84,   132,
-      85,    47,    87,    88,    44,    -5,   123,    89,    90,    51,
-      92,    52,    94,    95,    53,    54,   119,    55,    99,   100,
-      56,    57,    58,    45,    59,    60,    61,    62,    63,   112,
-      65,    64,    67,    66,    68,   105,    69,    70,    73,    72,
-      74,    75,    81,    86,    91,    93,    96,    97,   101,    98,
-     117,   106,   107,   110,   108,   122,     1,     2,   116,     3,
-       4,     5,     6,     7,     8,     9,   109,    10,    11,    12,
-      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,   111,    28,    29,    30,    31,
-      32,    33,    34,    35,    36,    37,    38,   118,   120,   121,
-     126,    -5,   129,   130,   131,   133,   134,   135,    76
-};
-
-#define yypact_value_is_default(yystate) \
-  ((yystate) == (-119))
-
-#define yytable_value_is_error(yytable_value) \
-  YYID (0)
-
-static const yytype_uint8 yycheck[] =
-{
-      33,    46,    47,    81,     3,   123,    10,     3,    53,   127,
-      55,     3,    57,    58,    18,     5,     6,    62,    63,     3,
-      65,     3,    67,    68,     3,     3,   104,     3,    73,    74,
-       5,     3,     3,    37,     3,     3,     3,     3,     3,   101,
-       3,     5,     3,     5,     3,   123,     3,     5,     3,     5,
-       3,     0,     6,     5,     5,     5,     3,     5,     3,     5,
-     103,     5,     5,     3,     5,   110,     8,     9,   101,    11,
-      12,    13,    14,    15,    16,    17,     5,    19,    20,    21,
-      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
-      32,    33,    34,    35,    36,     5,    38,    39,    40,    41,
-      42,    43,    44,    45,    46,    47,    48,     7,     5,     5,
-       5,     5,     3,     5,     7,     5,     5,     5,    40
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const yytype_uint8 yystos[] =
-{
-       0,     8,     9,    11,    12,    13,    14,    15,    16,    17,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    38,    39,
-      40,    41,    42,    43,    44,    45,    46,    47,    48,    51,
-      68,    69,     3,    10,    18,    37,     3,     3,    52,    60,
-      61,     3,     3,     3,     3,     3,     5,     3,     3,     3,
-       3,     3,     3,     3,     5,     3,     5,     3,     3,     3,
-       5,    60,     5,     3,     3,     0,    69,    64,    65,    64,
-      64,     6,    54,    63,    64,    64,     5,    64,    64,    64,
-      64,     5,    64,     5,    64,    64,     3,     5,     5,    64,
-      64,     3,    66,    67,    62,    63,     5,     5,     5,     5,
-       3,     5,    52,    55,    56,    57,    60,    66,     7,    63,
-       5,     5,    64,     6,    53,    59,     5,    58,    59,     3,
-       5,     7,    59,     5,     5,     5
-};
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  However,
-   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
-   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
-   discussed.  */
-
-#define YYFAIL		goto yyerrlab
-#if defined YYFAIL
-  /* This is here to suppress warnings from the GCC cpp's
-     -Wunused-macros.  Normally we don't worry about that warning, but
-     some users do, and we want to make it easy for users to remove
-     YYFAIL uses, which will produce warnings from Bison 2.5.  */
-#endif
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      YYPOPSTACK (1);						\
-      goto yybackup;						\
-    }								\
-  else								\
-    {								\
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;							\
-    }								\
-while (YYID (0))
-
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-
-/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
-   If N is 0, then set CURRENT to the empty location which ends
-   the previous symbol: RHS[0] (always defined).  */
-
-#define YYRHSLOC(Rhs, K) ((Rhs)[K])
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)				\
-    do									\
-      if (YYID (N))                                                    \
-	{								\
-	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
-	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
-	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
-	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
-	}								\
-      else								\
-	{								\
-	  (Current).first_line   = (Current).last_line   =		\
-	    YYRHSLOC (Rhs, 0).last_line;				\
-	  (Current).first_column = (Current).last_column =		\
-	    YYRHSLOC (Rhs, 0).last_column;				\
-	}								\
-    while (YYID (0))
-#endif
-
-
-/* This macro is provided for backward compatibility. */
-
-#ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-#endif
-
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (YYID (0))
-
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
-do {									  \
-  if (yydebug)								  \
-    {									  \
-      YYFPRINTF (stderr, "%s ", Title);					  \
-      yy_symbol_print (stderr,						  \
-		  Type, Value); \
-      YYFPRINTF (stderr, "\n");						  \
-    }									  \
-} while (YYID (0))
-
-
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
-static void
-yy_symbol_value_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
-{
-  if (!yyvaluep)
-    return;
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# else
-  YYUSE (yyoutput);
-# endif
-  switch (yytype)
-    {
-      default:
-	break;
-    }
-}
-
-
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
-static void
-yy_symbol_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
-{
-  if (yytype < YYNTOKENS)
-    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
-  YYFPRINTF (yyoutput, ")");
-}
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
-#else
-static void
-yy_stack_print (yybottom, yytop)
-    yytype_int16 *yybottom;
-    yytype_int16 *yytop;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (; yybottom <= yytop; yybottom++)
-    {
-      int yybot = *yybottom;
-      YYFPRINTF (stderr, " %d", yybot);
-    }
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (YYID (0))
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
-#else
-static void
-yy_reduce_print (yyvsp, yyrule)
-    YYSTYPE *yyvsp;
-    int yyrule;
-#endif
-{
-  int yynrhs = yyr2[yyrule];
-  int yyi;
-  unsigned long int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
-	     yyrule - 1, yylno);
-  /* The symbols being reduced.  */
-  for (yyi = 0; yyi < yynrhs; yyi++)
-    {
-      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
-      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
-		       &(yyvsp[(yyi + 1) - (yynrhs)])
-		       		       );
-      YYFPRINTF (stderr, "\n");
-    }
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (yyvsp, Rule); \
-} while (YYID (0))
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static YYSIZE_T
-yystrlen (const char *yystr)
-#else
-static YYSIZE_T
-yystrlen (yystr)
-    const char *yystr;
-#endif
-{
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static char *
-yystpcpy (char *yydest, const char *yysrc)
-#else
-static char *
-yystpcpy (yydest, yysrc)
-    char *yydest;
-    const char *yysrc;
-#endif
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYSIZE_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-	switch (*++yyp)
-	  {
-	  case '\'':
-	  case ',':
-	    goto do_not_strip_quotes;
-
-	  case '\\':
-	    if (*++yyp != '\\')
-	      goto do_not_strip_quotes;
-	    /* Fall through.  */
-	  default:
-	    if (yyres)
-	      yyres[yyn] = *yyp;
-	    yyn++;
-	    break;
-
-	  case '"':
-	    if (yyres)
-	      yyres[yyn] = '\0';
-	    return yyn;
-	  }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return yystpcpy (yyres, yystr) - yyres;
-}
-# endif
-
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
-{
-  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  YYSIZE_T yysize1;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = 0;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - Assume YYFAIL is not used.  It's too flawed to consider.  See
-       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
-       for details.  YYERROR is fine as it does not invoke this
-       function.
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-                if (! (yysize <= yysize1
-                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-                  return 2;
-                yysize = yysize1;
-              }
-        }
-    }
-
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
-
-  yysize1 = yysize + yystrlen (yyformat);
-  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-    return 2;
-  yysize = yysize1;
-
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
-
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
-}
-#endif /* YYERROR_VERBOSE */
-
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yymsg, yytype, yyvaluep)
-    const char *yymsg;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  YYUSE (yyvaluep);
-
-  if (!yymsg)
-    yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
-
-  switch (yytype)
-    {
-
-      default:
-	break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-#ifdef YYPARSE_PARAM
-#if defined __STDC__ || defined __cplusplus
-int yyparse (void *YYPARSE_PARAM);
-#else
-int yyparse ();
-#endif
-#else /* ! YYPARSE_PARAM */
-#if defined __STDC__ || defined __cplusplus
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-int
-yyparse (void *YYPARSE_PARAM)
-#else
-int
-yyparse (YYPARSE_PARAM)
-    void *YYPARSE_PARAM;
-#endif
-#else /* ! YYPARSE_PARAM */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-
-#endif
-#endif
-{
-    int yystate;
-    /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
-
-    /* The stacks and their tools:
-       `yyss': related to states.
-       `yyvs': related to semantic values.
-
-       Refer to the stacks thru separate pointers, to allow yyoverflow
-       to reallocate them elsewhere.  */
-
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
-
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
-
-    YYSIZE_T yystacksize;
-
-  int yyn;
-  int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken;
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
-
-#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
-
-  /* The number of symbols on the RHS of the reduced rule.
-     Keep to zero when no symbol should be popped.  */
-  int yylen = 0;
-
-  yytoken = 0;
-  yyss = yyssa;
-  yyvs = yyvsa;
-  yystacksize = YYINITDEPTH;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY; /* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed.  So pushing a state here evens the stacks.  */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack.  Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	yytype_int16 *yyss1 = yyss;
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow (YY_("memory exhausted"),
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyexhaustedlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	yytype_int16 *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss_alloc, yyss);
-	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  if (yystate == YYFINAL)
-    YYACCEPT;
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-  /* Do appropriate processing given the current state.  Read a
-     lookahead token if we need one and don't already have one.  */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-  yyn = yypact[yystate];
-  if (yypact_value_is_default (yyn))
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yytable_value_is_error (yyn))
-        goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  /* Shift the lookahead token.  */
-  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
-
-  yystate = yyn;
-  *++yyvsp = yylval;
-
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 2:
-
-/* Line 1821 of yacc.c  */
-#line 172 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 3:
-
-/* Line 1821 of yacc.c  */
-#line 178 "core/pbrtparse.yy"
-    {
-    if (cur_array) Severe("MUH");
-    cur_array = new ParamArray;
-}
-    break;
-
-  case 4:
-
-/* Line 1821 of yacc.c  */
-#line 186 "core/pbrtparse.yy"
-    {
-    cur_array->element_size = sizeof(const char *);
-    cur_array->isString = true;
-}
-    break;
-
-  case 5:
-
-/* Line 1821 of yacc.c  */
-#line 194 "core/pbrtparse.yy"
-    {
-    cur_array->element_size = sizeof(float);
-    cur_array->isString = false;
-}
-    break;
-
-  case 6:
-
-/* Line 1821 of yacc.c  */
-#line 202 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = (yyvsp[(1) - (1)].ribarray);
-}
-    break;
-
-  case 7:
-
-/* Line 1821 of yacc.c  */
-#line 208 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = (yyvsp[(1) - (1)].ribarray);
-}
-    break;
-
-  case 8:
-
-/* Line 1821 of yacc.c  */
-#line 215 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = cur_array;
-    cur_array = NULL;
-}
-    break;
-
-  case 9:
-
-/* Line 1821 of yacc.c  */
-#line 222 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = cur_array;
-    cur_array = NULL;
-}
-    break;
-
-  case 10:
-
-/* Line 1821 of yacc.c  */
-#line 230 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 11:
-
-/* Line 1821 of yacc.c  */
-#line 236 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 12:
-
-/* Line 1821 of yacc.c  */
-#line 241 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 13:
-
-/* Line 1821 of yacc.c  */
-#line 247 "core/pbrtparse.yy"
-    {
-    char *to_add = strdup((yyvsp[(2) - (2)].string));
-    AddArrayElement(&to_add);
-}
-    break;
-
-  case 14:
-
-/* Line 1821 of yacc.c  */
-#line 255 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = cur_array;
-    cur_array = NULL;
-}
-    break;
-
-  case 15:
-
-/* Line 1821 of yacc.c  */
-#line 262 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = cur_array;
-    cur_array = NULL;
-}
-    break;
-
-  case 16:
-
-/* Line 1821 of yacc.c  */
-#line 270 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 17:
-
-/* Line 1821 of yacc.c  */
-#line 276 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 18:
-
-/* Line 1821 of yacc.c  */
-#line 281 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 19:
-
-/* Line 1821 of yacc.c  */
-#line 287 "core/pbrtparse.yy"
-    {
-    float to_add = (yyvsp[(2) - (2)].num);
-    AddArrayElement(&to_add);
-}
-    break;
-
-  case 20:
-
-/* Line 1821 of yacc.c  */
-#line 295 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 21:
-
-/* Line 1821 of yacc.c  */
-#line 301 "core/pbrtparse.yy"
-    {
-    for (uint32_t i = 0; i < cur_paramlist.size(); ++i) {
-        if (cur_paramlist[i].isString) {
-            for (uint32_t j = 0; j < (uint32_t)cur_paramlist[i].size; ++j)
-                free(((char **)cur_paramlist[i].arg)[j]);
-        }
-    }
-    cur_paramlist.erase(cur_paramlist.begin(), cur_paramlist.end());
-}
-    break;
-
-  case 22:
-
-/* Line 1821 of yacc.c  */
-#line 314 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 23:
-
-/* Line 1821 of yacc.c  */
-#line 319 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 24:
-
-/* Line 1821 of yacc.c  */
-#line 325 "core/pbrtparse.yy"
-    {
-    cur_paramlist.push_back(ParamListItem((yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].ribarray)));
-    ArrayFree((yyvsp[(2) - (2)].ribarray));
-}
-    break;
-
-  case 25:
-
-/* Line 1821 of yacc.c  */
-#line 333 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 26:
-
-/* Line 1821 of yacc.c  */
-#line 338 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 27:
-
-/* Line 1821 of yacc.c  */
-#line 344 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtAccelerator((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 28:
-
-/* Line 1821 of yacc.c  */
-#line 353 "core/pbrtparse.yy"
-    {
-    pbrtActiveTransformAll();
-}
-    break;
-
-  case 29:
-
-/* Line 1821 of yacc.c  */
-#line 359 "core/pbrtparse.yy"
-    {
-    pbrtActiveTransformEndTime();
-}
-    break;
-
-  case 30:
-
-/* Line 1821 of yacc.c  */
-#line 365 "core/pbrtparse.yy"
-    {
-    pbrtActiveTransformStartTime();
-}
-    break;
-
-  case 31:
-
-/* Line 1821 of yacc.c  */
-#line 371 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_ILLUMINANT);
-    pbrtAreaLightSource((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 32:
-
-/* Line 1821 of yacc.c  */
-#line 380 "core/pbrtparse.yy"
-    {
-    pbrtAttributeBegin();
-}
-    break;
-
-  case 33:
-
-/* Line 1821 of yacc.c  */
-#line 386 "core/pbrtparse.yy"
-    {
-    pbrtAttributeEnd();
-}
-    break;
-
-  case 34:
-
-/* Line 1821 of yacc.c  */
-#line 392 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtCamera((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 35:
-
-/* Line 1821 of yacc.c  */
-#line 401 "core/pbrtparse.yy"
-    {
-    if (VerifyArrayLength((yyvsp[(2) - (2)].ribarray), 16, "ConcatTransform"))
-        pbrtConcatTransform((float *) (yyvsp[(2) - (2)].ribarray)->array);
-    ArrayFree((yyvsp[(2) - (2)].ribarray));
-}
-    break;
-
-  case 36:
-
-/* Line 1821 of yacc.c  */
-#line 409 "core/pbrtparse.yy"
-    {
-    pbrtCoordinateSystem((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 37:
-
-/* Line 1821 of yacc.c  */
-#line 415 "core/pbrtparse.yy"
-    {
-    pbrtCoordSysTransform((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 38:
-
-/* Line 1821 of yacc.c  */
-#line 421 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtFilm((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 39:
-
-/* Line 1821 of yacc.c  */
-#line 430 "core/pbrtparse.yy"
-    {
-    pbrtIdentity();
-}
-    break;
-
-  case 40:
-
-/* Line 1821 of yacc.c  */
-#line 436 "core/pbrtparse.yy"
-    {
-  include_push((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 41:
-
-/* Line 1821 of yacc.c  */
-#line 442 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_ILLUMINANT);
-    pbrtLightSource((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 42:
-
-/* Line 1821 of yacc.c  */
-#line 451 "core/pbrtparse.yy"
-    {
-    pbrtLookAt((yyvsp[(2) - (10)].num), (yyvsp[(3) - (10)].num), (yyvsp[(4) - (10)].num), (yyvsp[(5) - (10)].num), (yyvsp[(6) - (10)].num), (yyvsp[(7) - (10)].num), (yyvsp[(8) - (10)].num), (yyvsp[(9) - (10)].num), (yyvsp[(10) - (10)].num));
-}
-    break;
-
-  case 43:
-
-/* Line 1821 of yacc.c  */
-#line 457 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtMakeNamedMaterial((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 44:
-
-/* Line 1821 of yacc.c  */
-#line 466 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtMaterial((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 45:
-
-/* Line 1821 of yacc.c  */
-#line 475 "core/pbrtparse.yy"
-    {
-    pbrtNamedMaterial((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 46:
-
-/* Line 1821 of yacc.c  */
-#line 481 "core/pbrtparse.yy"
-    {
-    pbrtObjectBegin((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 47:
-
-/* Line 1821 of yacc.c  */
-#line 487 "core/pbrtparse.yy"
-    {
-    pbrtObjectEnd();
-}
-    break;
-
-  case 48:
-
-/* Line 1821 of yacc.c  */
-#line 493 "core/pbrtparse.yy"
-    {
-    pbrtObjectInstance((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 49:
-
-/* Line 1821 of yacc.c  */
-#line 499 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtPixelFilter((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 50:
-
-/* Line 1821 of yacc.c  */
-#line 508 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtRenderer((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 51:
-
-/* Line 1821 of yacc.c  */
-#line 517 "core/pbrtparse.yy"
-    {
-    pbrtReverseOrientation();
-}
-    break;
-
-  case 52:
-
-/* Line 1821 of yacc.c  */
-#line 523 "core/pbrtparse.yy"
-    {
-    pbrtRotate((yyvsp[(2) - (5)].num), (yyvsp[(3) - (5)].num), (yyvsp[(4) - (5)].num), (yyvsp[(5) - (5)].num));
-}
-    break;
-
-  case 53:
-
-/* Line 1821 of yacc.c  */
-#line 529 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtSampler((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 54:
-
-/* Line 1821 of yacc.c  */
-#line 538 "core/pbrtparse.yy"
-    {
-    pbrtScale((yyvsp[(2) - (4)].num), (yyvsp[(3) - (4)].num), (yyvsp[(4) - (4)].num));
-}
-    break;
-
-  case 55:
-
-/* Line 1821 of yacc.c  */
-#line 544 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtShape((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 56:
-
-/* Line 1821 of yacc.c  */
-#line 553 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtSurfaceIntegrator((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 57:
-
-/* Line 1821 of yacc.c  */
-#line 562 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtTexture((yyvsp[(2) - (5)].string), (yyvsp[(3) - (5)].string), (yyvsp[(4) - (5)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 58:
-
-/* Line 1821 of yacc.c  */
-#line 571 "core/pbrtparse.yy"
-    {
-    pbrtTransformBegin();
-}
-    break;
-
-  case 59:
-
-/* Line 1821 of yacc.c  */
-#line 577 "core/pbrtparse.yy"
-    {
-    pbrtTransformEnd();
-}
-    break;
-
-  case 60:
-
-/* Line 1821 of yacc.c  */
-#line 583 "core/pbrtparse.yy"
-    {
-    pbrtTransformTimes((yyvsp[(2) - (3)].num), (yyvsp[(3) - (3)].num));
-}
-    break;
-
-  case 61:
-
-/* Line 1821 of yacc.c  */
-#line 589 "core/pbrtparse.yy"
-    {
-    if (VerifyArrayLength( (yyvsp[(2) - (2)].ribarray), 16, "Transform" ))
-        pbrtTransform( (float *) (yyvsp[(2) - (2)].ribarray)->array );
-    ArrayFree((yyvsp[(2) - (2)].ribarray));
-}
-    break;
-
-  case 62:
-
-/* Line 1821 of yacc.c  */
-#line 597 "core/pbrtparse.yy"
-    {
-    pbrtTranslate((yyvsp[(2) - (4)].num), (yyvsp[(3) - (4)].num), (yyvsp[(4) - (4)].num));
-}
-    break;
-
-  case 63:
-
-/* Line 1821 of yacc.c  */
-#line 603 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtVolumeIntegrator((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 64:
-
-/* Line 1821 of yacc.c  */
-#line 612 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtVolume((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 65:
-
-/* Line 1821 of yacc.c  */
-#line 621 "core/pbrtparse.yy"
-    {
-    pbrtWorldBegin();
-}
-    break;
-
-  case 66:
-
-/* Line 1821 of yacc.c  */
-#line 627 "core/pbrtparse.yy"
-    {
-    pbrtWorldEnd();
-}
-    break;
-
-
-
-/* Line 1821 of yacc.c  */
-#line 2278 "core/pbrtparse.cpp"
-      default: break;
-    }
-  /* User semantic actions sometimes alter yychar, and that requires
-     that yytoken be updated with the new translation.  We take the
-     approach of translating immediately before every use of yytoken.
-     One alternative is translating here after every semantic action,
-     but that translation would be missed if the semantic action invokes
-     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
-     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
-     incorrect destructor might then be invoked immediately.  In the
-     case of YYERROR or YYBACKUP, subsequent parser actions might lead
-     to an incorrect destructor call or verbose syntax error message
-     before the lookahead is translated.  */
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
-
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* Make sure we have latest lookahead translation.  See comments at
-     user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if ! YYERROR_VERBOSE
-      yyerror (YY_("syntax error"));
-#else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
-      {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
-      }
-# undef YYSYNTAX_ERROR
-#endif
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-	{
-	  /* Return failure if at end of input.  */
-	  if (yychar == YYEOF)
-	    YYABORT;
-	}
-      else
-	{
-	  yydestruct ("Error: discarding",
-		      yytoken, &yylval);
-	  yychar = YYEMPTY;
-	}
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (/*CONSTCOND*/ 0)
-     goto yyerrorlab;
-
-  /* Do not reclaim the symbols of the rule which action triggered
-     this YYERROR.  */
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (!yypact_value_is_default (yyn))
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-
-      yydestruct ("Error: popping",
-		  yystos[yystate], yyvsp);
-      YYPOPSTACK (1);
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  *++yyvsp = yylval;
-
-
-  /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#if !defined(yyoverflow) || YYERROR_VERBOSE
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
-yyexhaustedlab:
-  yyerror (YY_("memory exhausted"));
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-  if (yychar != YYEMPTY)
-    {
-      /* Make sure we have latest lookahead translation.  See comments at
-         user semantic actions for why this is necessary.  */
-      yytoken = YYTRANSLATE (yychar);
-      yydestruct ("Cleanup: discarding lookahead",
-                  yytoken, &yylval);
-    }
-  /* Do not reclaim the symbols of the rule which action triggered
-     this YYABORT or YYACCEPT.  */
-  YYPOPSTACK (yylen);
-  YY_STACK_PRINT (yyss, yyssp);
-  while (yyssp != yyss)
-    {
-      yydestruct ("Cleanup: popping",
-		  yystos[*yyssp], yyvsp);
-      YYPOPSTACK (1);
-    }
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
-#endif
-  /* Make sure YYID is used.  */
-  return YYID (yyresult);
-}
-
-
-
-/* Line 2067 of yacc.c  */
-#line 632 "core/pbrtparse.yy"
-
-static const char *paramTypeToName(int type) {
-    switch (type) {
-    case PARAM_TYPE_INT: return "int";
-    case PARAM_TYPE_BOOL: return "bool";
-    case PARAM_TYPE_FLOAT: return "float";
-    case PARAM_TYPE_POINT: return "point";
-    case PARAM_TYPE_VECTOR: return "vector";
-    case PARAM_TYPE_NORMAL: return "normal";
-    case PARAM_TYPE_RGB: return "rgb/color";
-    case PARAM_TYPE_XYZ: return "xyz";
-    case PARAM_TYPE_BLACKBODY: return "blackbody";
-    case PARAM_TYPE_SPECTRUM: return "spectrum";
-    case PARAM_TYPE_STRING: return "string";
-    case PARAM_TYPE_TEXTURE: return "texture";
-    default: Severe("Error in paramTypeToName"); return NULL;
-    }
-}
-
-
-static void InitParamSet(ParamSet &ps, SpectrumType type) {
-    ps.Clear();
-    for (uint32_t i = 0; i < cur_paramlist.size(); ++i) {
-        int type;
-        string name;
-        if (lookupType(cur_paramlist[i].name, &type, name)) {
-            if (type == PARAM_TYPE_TEXTURE || type == PARAM_TYPE_STRING ||
-                type == PARAM_TYPE_BOOL) {
-                if (!cur_paramlist[i].isString) {
-                    Error("Expected string parameter value for parameter \"%s\" with type \"%s\". Ignoring.",
-                          name.c_str(), paramTypeToName(type));
-                    continue;
-                }
-            }
-            else if (type != PARAM_TYPE_SPECTRUM) { /* spectrum can be either... */
-                if (cur_paramlist[i].isString) {
-                    Error("Expected numeric parameter value for parameter \"%s\" with type \"%s\".  Ignoring.",
-                          name.c_str(), paramTypeToName(type));
-                    continue;
-                }
-            }
-            void *data = cur_paramlist[i].arg;
-            int nItems = cur_paramlist[i].size;
-            if (type == PARAM_TYPE_INT) {
-                // parser doesn't handle ints, so convert from floats here....
-                int nAlloc = nItems;
-                int *idata = new int[nAlloc];
-                float *fdata = (float *)cur_paramlist[i].arg;
-                for (int j = 0; j < nAlloc; ++j)
-                    idata[j] = int(fdata[j]);
-                ps.AddInt(name, idata, nItems);
-                delete[] idata;
-            }
-            else if (type == PARAM_TYPE_BOOL) {
-                // strings -> bools
-                int nAlloc = cur_paramlist[i].size;
-                bool *bdata = new bool[nAlloc];
-                for (int j = 0; j < nAlloc; ++j) {
-                    string s(((const char **)data)[j]);
-                    if (s == "true") bdata[j] = true;
-                    else if (s == "false") bdata[j] = false;
-                    else {
-                        Warning("Value \"%s\" unknown for boolean parameter \"%s\"."
-                            "Using \"false\".", s.c_str(), cur_paramlist[i].name);
-                        bdata[j] = false;
-                    }
-                }
-                ps.AddBool(name, bdata, nItems);
-                delete[] bdata;
-            }
-            else if (type == PARAM_TYPE_FLOAT) {
-                ps.AddFloat(name, (float *)data, nItems);
-            } else if (type == PARAM_TYPE_POINT) {
-                if ((nItems % 3) != 0)
-                    Warning("Excess values given with point parameter \"%s\". "
-                            "Ignoring last %d of them", cur_paramlist[i].name, nItems % 3);
-                ps.AddPoint(name, (Point *)data, nItems / 3);
-            } else if (type == PARAM_TYPE_VECTOR) {
-                if ((nItems % 3) != 0)
-                    Warning("Excess values given with vector parameter \"%s\". "
-                            "Ignoring last %d of them", cur_paramlist[i].name, nItems % 3);
-                ps.AddVector(name, (Vector *)data, nItems / 3);
-            } else if (type == PARAM_TYPE_NORMAL) {
-                if ((nItems % 3) != 0)
-                    Warning("Excess values given with normal parameter \"%s\". "
-                            "Ignoring last %d of them", cur_paramlist[i].name, nItems % 3);
-                ps.AddNormal(name, (Normal *)data, nItems / 3);
-            } else if (type == PARAM_TYPE_RGB) {
-                if ((nItems % 3) != 0)
-                    Warning("Excess RGB values given with parameter \"%s\". "
-                            "Ignoring last %d of them", cur_paramlist[i].name, nItems % 3);
-                ps.AddRGBSpectrum(name, (float *)data, nItems);
-            } else if (type == PARAM_TYPE_XYZ) {
-                if ((nItems % 3) != 0)
-                    Warning("Excess XYZ values given with parameter \"%s\". "
-                            "Ignoring last %d of them", cur_paramlist[i].name, nItems % 3);
-                ps.AddXYZSpectrum(name, (float *)data, nItems);
-            } else if (type == PARAM_TYPE_BLACKBODY) {
-                if ((nItems % 2) != 0)
-                    Warning("Excess value given with blackbody parameter \"%s\". "
-                            "Ignoring extra one.", cur_paramlist[i].name);
-                ps.AddBlackbodySpectrum(name, (float *)data, nItems);
-            } else if (type == PARAM_TYPE_SPECTRUM) {
-                if (cur_paramlist[i].isString) {
-                    ps.AddSampledSpectrumFiles(name, (const char **)data, nItems);
-                }
-                else {
-                    if ((nItems % 2) != 0)
-                        Warning("Non-even number of values given with sampled spectrum "
-                                "parameter \"%s\". Ignoring extra.", cur_paramlist[i].name);
-                    ps.AddSampledSpectrum(name, (float *)data, nItems);
-                }
-            } else if (type == PARAM_TYPE_STRING) {
-                string *strings = new string[nItems];
-                for (int j = 0; j < nItems; ++j)
-                    strings[j] = string(((const char **)data)[j]);
-                ps.AddString(name, strings, nItems);
-                delete[] strings;
-            }
-            else if (type == PARAM_TYPE_TEXTURE) {
-                if (nItems == 1) {
-                    string val(*((const char **)data));
-                    ps.AddTexture(name, val);
-                }
-                else
-                    Error("Only one string allowed for \"texture\" parameter \"%s\"",
-                        name.c_str());
-            }
-        }
-        else
-            Warning("Type of parameter \"%s\" is unknown",
-                cur_paramlist[i].name);
-    }
-}
-
-
-static bool lookupType(const char *name, int *type, string &sname) {
-    Assert(name != NULL);
-    *type = 0;
-    const char *strp = name;
-    while (*strp && isspace(*strp))
-        ++strp;
-    if (!*strp) {
-        Error("Parameter \"%s\" doesn't have a type declaration?!", name);
-        return false;
-    }
-#define TRY_DECODING_TYPE(name, mask) \
-        if (strncmp(name, strp, strlen(name)) == 0) { \
-            *type = mask; strp += strlen(name); \
-        }
-         TRY_DECODING_TYPE("float",     PARAM_TYPE_FLOAT)
-    else TRY_DECODING_TYPE("integer",   PARAM_TYPE_INT)
-    else TRY_DECODING_TYPE("bool",      PARAM_TYPE_BOOL)
-    else TRY_DECODING_TYPE("point",     PARAM_TYPE_POINT)
-    else TRY_DECODING_TYPE("vector",    PARAM_TYPE_VECTOR)
-    else TRY_DECODING_TYPE("normal",    PARAM_TYPE_NORMAL)
-    else TRY_DECODING_TYPE("string",    PARAM_TYPE_STRING)
-    else TRY_DECODING_TYPE("texture",   PARAM_TYPE_TEXTURE)
-    else TRY_DECODING_TYPE("color",     PARAM_TYPE_RGB)
-    else TRY_DECODING_TYPE("rgb",       PARAM_TYPE_RGB)
-    else TRY_DECODING_TYPE("xyz",       PARAM_TYPE_XYZ)
-    else TRY_DECODING_TYPE("blackbody", PARAM_TYPE_BLACKBODY)
-    else TRY_DECODING_TYPE("spectrum",  PARAM_TYPE_SPECTRUM)
-    else {
-        Error("Unable to decode type for name \"%s\"", name);
-        return false;
-    }
-    while (*strp && isspace(*strp))
-        ++strp;
-    sname = string(strp);
-    return true;
-}
-
-
-
diff -uarN 2015_kalantari_lbf/core/pbrtparse.hh ../methods/2015_kalantari_lbf/core/pbrtparse.hh
--- 2015_kalantari_lbf/core/pbrtparse.hh	2013-07-09 07:53:44.000000000 -0700
+++ ../methods/2015_kalantari_lbf/core/pbrtparse.hh	1969-12-31 16:00:00.000000000 -0800
@@ -1,115 +0,0 @@
-/* A Bison parser, made by GNU Bison 2.5.1.  */
-
-/* Bison interface for Yacc-like parsers in C
-   
-      Copyright (C) 1984, 1989-1990, 2000-2012 Free Software Foundation, Inc.
-   
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* As a special exception, you may create a larger work that contains
-   part or all of the Bison parser skeleton and distribute that work
-   under terms of your choice, so long as that work isn't itself a
-   parser generator using the skeleton or a modified version thereof
-   as a parser skeleton.  Alternatively, if you modify or redistribute
-   the parser skeleton itself, you may (at your option) remove this
-   special exception, which will cause the skeleton and the resulting
-   Bison output files to be licensed under the GNU General Public
-   License without this special exception.
-   
-   This special exception was added by the Free Software Foundation in
-   version 2.2 of Bison.  */
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     STRING = 258,
-     ID = 259,
-     NUM = 260,
-     LBRACK = 261,
-     RBRACK = 262,
-     ACCELERATOR = 263,
-     ACTIVETRANSFORM = 264,
-     ALL = 265,
-     AREALIGHTSOURCE = 266,
-     ATTRIBUTEBEGIN = 267,
-     ATTRIBUTEEND = 268,
-     CAMERA = 269,
-     CONCATTRANSFORM = 270,
-     COORDINATESYSTEM = 271,
-     COORDSYSTRANSFORM = 272,
-     ENDTIME = 273,
-     FILM = 274,
-     IDENTITY = 275,
-     INCLUDE = 276,
-     LIGHTSOURCE = 277,
-     LOOKAT = 278,
-     MAKENAMEDMATERIAL = 279,
-     MATERIAL = 280,
-     NAMEDMATERIAL = 281,
-     OBJECTBEGIN = 282,
-     OBJECTEND = 283,
-     OBJECTINSTANCE = 284,
-     PIXELFILTER = 285,
-     RENDERER = 286,
-     REVERSEORIENTATION = 287,
-     ROTATE = 288,
-     SAMPLER = 289,
-     SCALE = 290,
-     SHAPE = 291,
-     STARTTIME = 292,
-     SURFACEINTEGRATOR = 293,
-     TEXTURE = 294,
-     TRANSFORMBEGIN = 295,
-     TRANSFORMEND = 296,
-     TRANSFORMTIMES = 297,
-     TRANSFORM = 298,
-     TRANSLATE = 299,
-     VOLUME = 300,
-     VOLUMEINTEGRATOR = 301,
-     WORLDBEGIN = 302,
-     WORLDEND = 303,
-     HIGH_PRECEDENCE = 304
-   };
-#endif
-
-
-
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef union YYSTYPE
-{
-
-/* Line 2136 of yacc.c  */
-#line 157 "build/darwin-debug/core/pbrtparse.yy"
-
-char string[1024];
-float num;
-ParamArray *ribarray;
-
-
-
-/* Line 2136 of yacc.c  */
-#line 107 "build/darwin-debug/core/pbrtparse.hh"
-} YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-#endif
-
-extern YYSTYPE yylval;
-
-
diff -uarN 2015_kalantari_lbf/core/reflection.h ../methods/2015_kalantari_lbf/core/reflection.h
--- 2015_kalantari_lbf/core/reflection.h	2015-04-14 18:14:36.000000000 -0700
+++ ../methods/2015_kalantari_lbf/core/reflection.h	2019-09-11 11:26:25.576201709 -0700
@@ -421,7 +421,7 @@
 
 class Blinn : public MicrofacetDistribution {
 public:
-    Blinn(float e) { if (e > 10000.f || isnan(e)) e = 10000.f;
+    Blinn(float e) { if (e > 10000.f || std::isnan(e)) e = 10000.f;
                      exponent = e; }
     // Blinn Public Methods
     float D(const Vector &wh) const {
@@ -440,8 +440,8 @@
     // Anisotropic Public Methods
     Anisotropic(float x, float y) {
         ex = x; ey = y;
-        if (ex > 10000.f || isnan(ex)) ex = 10000.f;
-        if (ey > 10000.f || isnan(ey)) ey = 10000.f;
+        if (ex > 10000.f || std::isnan(ex)) ex = 10000.f;
+        if (ey > 10000.f || std::isnan(ey)) ey = 10000.f;
     }
     float D(const Vector &wh) const {
         float costhetah = AbsCosTheta(wh);
diff -uarN 2015_kalantari_lbf/core/shape.cpp ../methods/2015_kalantari_lbf/core/shape.cpp
--- 2015_kalantari_lbf/core/shape.cpp	2013-07-09 07:53:44.000000000 -0700
+++ ../methods/2015_kalantari_lbf/core/shape.cpp	2019-09-11 11:26:25.576201709 -0700
@@ -94,7 +94,7 @@
     // Convert light sample weight to solid angle measure
     float pdf = DistanceSquared(p, ray(thit)) /
                 (AbsDot(dgLight.nn, -wi) * Area());
-    if (isinf(pdf)) pdf = 0.f;
+    if (std::isinf(pdf)) pdf = 0.f;
     return pdf;
 }
 
diff -uarN 2015_kalantari_lbf/core/spectrum.h ../methods/2015_kalantari_lbf/core/spectrum.h
--- 2015_kalantari_lbf/core/spectrum.h	2013-07-09 07:53:44.000000000 -0700
+++ ../methods/2015_kalantari_lbf/core/spectrum.h	2019-09-11 11:26:25.576201709 -0700
@@ -177,11 +177,11 @@
     }
     friend inline
     CoefficientSpectrum operator*(float a, const CoefficientSpectrum &s) {
-        Assert(!isnan(a) && !s.HasNaNs());
+        Assert(!std::isnan(a) && !s.HasNaNs());
         return s * a;
     }
     CoefficientSpectrum operator/(float a) const {
-        Assert(!isnan(a));
+        Assert(!std::isnan(a));
         CoefficientSpectrum ret = *this;
         for (int i = 0; i < nSamples; ++i)
             ret.c[i] /= a;
@@ -189,7 +189,7 @@
         return ret;
     }
     CoefficientSpectrum &operator/=(float a) {
-        Assert(!isnan(a));
+        Assert(!std::isnan(a));
         for (int i = 0; i < nSamples; ++i)
             c[i] /= a;
         return *this;
@@ -237,7 +237,7 @@
     }
     bool HasNaNs() const {
         for (int i = 0; i < nSamples; ++i)
-            if (isnan(c[i])) return true;
+            if (std::isnan(c[i])) return true;
         return false;
     }
     bool Write(FILE *f) const {
diff -uarN 2015_kalantari_lbf/core/transform.cpp ../methods/2015_kalantari_lbf/core/transform.cpp
--- 2015_kalantari_lbf/core/transform.cpp	2013-07-09 07:53:44.000000000 -0700
+++ ../methods/2015_kalantari_lbf/core/transform.cpp	2019-09-11 11:26:25.576201709 -0700
@@ -43,7 +43,7 @@
         return false;
     *x0 = (A[1][1]*B[0] - A[0][1]*B[1]) / det;
     *x1 = (A[0][0]*B[1] - A[1][0]*B[0]) / det;
-    if (isnan(*x0) || isnan(*x1))
+    if (std::isnan(*x0) || std::isnan(*x1))
         return false;
     return true;
 }
diff -uarN 2015_kalantari_lbf/film/image.cpp ../methods/2015_kalantari_lbf/film/image.cpp
--- 2015_kalantari_lbf/film/image.cpp	2015-05-20 14:29:02.000000000 -0700
+++ ../methods/2015_kalantari_lbf/film/image.cpp	2019-09-11 11:26:25.576201709 -0700
@@ -38,7 +38,8 @@
 #include "imageio.h"
 #include "../SampleWriter/Globals.h"
 #include "../SampleWriter/SampleWriter.h" // MOD
-#include <direct.h>
+// #include <direct.h>
+#include <sys/stat.h>
 
 extern char sceneName[BUFFER_SIZE];
 extern int pbrtSamplesPerPixel;
@@ -257,20 +258,23 @@
 	}
 
 	// Make output directory
-	char extension[BUFFER_SIZE];
-	if(pbrtSamplesPerPixel != 0)
-		sprintf(extension, "_MC_%04d.exr", pbrtSamplesPerPixel);
-	else
-		sprintf(extension, "_MC.exr");
-
-	filename = std::string(sceneName) + std::string(extension);	
+	// char extension[BUFFER_SIZE];
+	// if(pbrtSamplesPerPixel != 0)
+	// 	sprintf(extension, "_MC_%04d.exr", pbrtSamplesPerPixel);
+	// else
+	// 	sprintf(extension, "_MC.exr");
+  //
+	// filename = std::string(sceneName) + std::string(extension);	
+	filename = std::string(sceneName) + std::string(".exr");	
 	size_t lastslash = filename.find_last_of("\\");
 	int lastbackslash = filename.find_last_of("/");
 	lastslash = (lastslash > lastbackslash) ? lastslash : lastbackslash;
 	if (lastslash != std::string::npos) {
 		std::string outputFolder = filename.substr(0, lastslash + 1);
-		_mkdir(outputFolder.c_str());
-		strerror(errno);
+    // TODO(mgharbi)
+		// _mkdir(outputFolder.c_str());
+    const int dir_err = mkdir(outputFolder.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+		// strerror(errno);
 	}
 						
 	//***************************************************//
diff -uarN 2015_kalantari_lbf/integrators/igi.cpp ../methods/2015_kalantari_lbf/integrators/igi.cpp
--- 2015_kalantari_lbf/integrators/igi.cpp	2014-05-27 21:54:00.000000000 -0700
+++ ../methods/2015_kalantari_lbf/integrators/igi.cpp	2019-09-11 11:26:25.576201709 -0700
@@ -210,7 +210,7 @@
                 // Add bias compensation ray contribution to radiance sum
                 float Ggather = AbsDot(wi, n) * AbsDot(-wi, gatherIsect.dg.nn) /
                     DistanceSquared(p, gatherIsect.dg.p);
-                if (Ggather - gLimit > 0.f && !isinf(Ggather)) {
+                if (Ggather - gLimit > 0.f && !std::isinf(Ggather)) {
                     float gs = (Ggather - gLimit) / Ggather;
                     L += f * Li * (AbsDot(wi, n) * gs / (nSamples * pdf));
                 }
diff -uarN 2015_kalantari_lbf/LBF/CImg.h ../methods/2015_kalantari_lbf/LBF/CImg.h
--- 2015_kalantari_lbf/LBF/CImg.h	2014-01-17 11:43:26.000000000 -0800
+++ ../methods/2015_kalantari_lbf/LBF/CImg.h	2019-09-11 11:26:25.572201673 -0700
@@ -181,9 +181,9 @@
 #define cimg_display 0
 #elif cimg_OS==1
 #if defined(__MACOSX__) || defined(__APPLE__)
-#define cimg_display 1
+#define cimg_display 0
 #else
-#define cimg_display 1
+#define cimg_display 0
 #endif
 #elif cimg_OS==2
 #define cimg_display 2
diff -uarN 2015_kalantari_lbf/LBF/CudaWrappers.cuh ../methods/2015_kalantari_lbf/LBF/CudaWrappers.cuh
--- 2015_kalantari_lbf/LBF/CudaWrappers.cuh	2015-05-18 15:55:58.000000000 -0700
+++ ../methods/2015_kalantari_lbf/LBF/CudaWrappers.cuh	2019-09-11 11:26:25.572201673 -0700
@@ -3,8 +3,8 @@
 
 #include <cuda.h>
 #include <cuda_runtime.h>
-#include "Globals.h"
-#include "Matrix.h"
+#include "LBF/Globals.h"
+#include "LBF/Matrix.h"
 
 cudaChannelFormatDesc channelDesc;
 cudaArray* devSampleArray;
@@ -507,4 +507,4 @@
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff -uarN 2015_kalantari_lbf/LBF/FeatureExtractor.cpp ../methods/2015_kalantari_lbf/LBF/FeatureExtractor.cpp
--- 2015_kalantari_lbf/LBF/FeatureExtractor.cpp	2015-05-21 11:47:44.000000000 -0700
+++ ../methods/2015_kalantari_lbf/LBF/FeatureExtractor.cpp	2019-09-11 11:26:25.572201673 -0700
@@ -1,4 +1,5 @@
-#include "FeatureExtractor.h"
+#include "LBF/FeatureExtractor.h"
+#include <string.h>
 
 void PrintError(cudaError_t err, char* file, int line);
 void CalcGradients(float* featureData, float* normMu, float* normStd, int width, int height, int featureLength);
@@ -649,4 +650,4 @@
 			varData[SAMPLE_LENGTH * i + j] *= varNorm;
 		}
 	}
-}
\ No newline at end of file
+}
diff -uarN 2015_kalantari_lbf/LBF/FeatureExtractor.h ../methods/2015_kalantari_lbf/LBF/FeatureExtractor.h
--- 2015_kalantari_lbf/LBF/FeatureExtractor.h	2015-05-15 15:04:26.000000000 -0700
+++ ../methods/2015_kalantari_lbf/LBF/FeatureExtractor.h	2019-09-11 11:26:25.572201673 -0700
@@ -11,7 +11,7 @@
 #include <algorithm>
 #include <cuda.h>
 #include <cuda_runtime.h>
-#include "Globals.h"
+#include "LBF/Globals.h"
 
 using namespace std;
 
@@ -81,4 +81,4 @@
 	
 };
 
-#endif
\ No newline at end of file
+#endif
diff -uarN 2015_kalantari_lbf/LBF/Globals.h ../methods/2015_kalantari_lbf/LBF/Globals.h
--- 2015_kalantari_lbf/LBF/Globals.h	2015-05-18 13:42:38.000000000 -0700
+++ ../methods/2015_kalantari_lbf/LBF/Globals.h	2019-09-11 11:26:25.572201673 -0700
@@ -1,12 +1,15 @@
 #ifndef	GLOBALS_FEATURE_H_INCLUDED
 #define GLOBALS_FEATURE_H_INCLUDED
 
+#define CUDA_NO_HALF
+
 #include <vector>
 #include <random>
-#include "CImg.h"
+// #include "CImg.h"
+#include "LBF/Utilities.h"
 
-using namespace std;
-using namespace cimg_library;
+// using namespace std;
+// using namespace cimg_library;
 
 typedef float (*ActivationFunc)(float);
 
@@ -123,4 +126,4 @@
 	#define CUDA_ERROR_CHECK
 #endif
 
-#endif
\ No newline at end of file
+#endif
diff -uarN 2015_kalantari_lbf/LBF/LBF.cpp ../methods/2015_kalantari_lbf/LBF/LBF.cpp
--- 2015_kalantari_lbf/LBF/LBF.cpp	2015-05-18 14:24:50.000000000 -0700
+++ ../methods/2015_kalantari_lbf/LBF/LBF.cpp	2019-09-11 11:26:25.572201673 -0700
@@ -3,11 +3,11 @@
 #include <random>
 #include <assert.h>
 #include <fstream>
-#include "Globals.h"
-#include "CImg.h"
-#include "FeatureExtractor.h"
-#include "NeuralNetwork.h"
-#include "../core/timer.h"
+#include "LBF/Globals.h"
+#include "LBF/CImg.h"
+#include "LBF/FeatureExtractor.h"
+#include "LBF/NeuralNetwork.h"
+#include "core/timer.h"
 
 using namespace std;
 
@@ -29,10 +29,10 @@
 	
 	// Record time
 	char fileName[1000];
-	sprintf(fileName, "%s/%s_timing.txt", inputFolder, sceneName);
-	FILE* fp = OpenFile(fileName, "at");
+	// sprintf(fileName, "%s/%s_timing.txt", inputFolder, sceneName);
+	// FILE* fp = OpenFile(fileName, "at");
 	featureTimer.Stop();
-	fprintf(fp, "Feature Extraction Time: %f sec\n", featureTimer.Time() + time);
+	// fprintf(fp, "Feature Extraction Time: %f sec\n", featureTimer.Time() + time);
 	featureTimer.Reset();
 	featureTimer.Start();
 
@@ -52,8 +52,8 @@
 
 	// Record time
 	featureTimer.Stop();
-	fprintf(fp, "NN/Filter Time: %f sec\n", featureTimer.Time());
-	fclose(fp);
+	// fprintf(fp, "NN/Filter Time: %f sec\n", featureTimer.Time());
+	// fclose(fp);
 
 }
 
diff -uarN 2015_kalantari_lbf/LBF/Matrix.h ../methods/2015_kalantari_lbf/LBF/Matrix.h
--- 2015_kalantari_lbf/LBF/Matrix.h	2015-04-15 11:15:32.000000000 -0700
+++ ../methods/2015_kalantari_lbf/LBF/Matrix.h	2019-09-11 11:26:25.572201673 -0700
@@ -11,8 +11,9 @@
 #include <cuda.h>
 #include <cuda_runtime_api.h>
 #include "cuda_runtime.h"
-#include "Utilities.h"
-#include "CImg.h"
+#include "LBF/Utilities.h"
+#include "LBF/Globals.h"
+#include "LBF/CImg.h"
 
 using namespace std;
 using namespace cimg_library;
@@ -90,6 +91,7 @@
 	void setElements(T* elements);
 	void AllocateData(bool isCudaMat);
 
+	bool isCudaMat;
 private:
 
 	//***** DATA *****//
@@ -98,7 +100,6 @@
 	int height;
 	int depth;
 	T* elements;
-	bool isCudaMat;
 
 };
 
@@ -243,9 +244,9 @@
 template<class T>
 Matrix<T>::~Matrix() 
 {
-
 	if(elements != NULL) 
 	{
+		printf("destroy %p [%d %d %d] cuda=%d\n", elements, width, height, depth, isCudaMat);
 		if(!isCudaMat)
 		{
 			delete[] elements;
@@ -260,7 +261,12 @@
 		{
 			elements = NULL;
 		}
+		printf(" post-destroy %p [%d %d %d] cuda=%d\n", elements, width, height, depth, isCudaMat);
 	}
+	// this->width = 0;
+	// this->height = 0;
+	// this->depth = 0;
+	// this->isCudaMat = false;
 	
 }
 
@@ -477,7 +483,8 @@
 
 	assert(!isCudaMat);
 
-	FILE* fp = OpenFile(fileName, "wb");
+	FILE* fp = fopen(fileName, "wb");
+	// FILE* fp = OpenFile(fileName, "wb");
 
 	fwrite(&this->width, sizeof(int), 1, fp);
 	fwrite(&this->height, sizeof(int), 1, fp);
@@ -495,7 +502,8 @@
 	assert(!isCudaMat);
 	assert(depthInd < this->depth);
 
-	FILE* fp = OpenFile(fileName, "wb");
+	FILE* fp = fopen(fileName, "wb");
+	// FILE* fp = OpenFile(fileName, "wb");
 
 	int depth = 1;
 
@@ -601,7 +609,6 @@
 template<class T>
 void Matrix<T>::HostToDevice(Matrix<T>& deviceMat) 
 {
-
 	assert(!isCudaMat);
 	assert(deviceMat.getWidth() == this->width && deviceMat.getHeight() == this->height && deviceMat.getDepth() == this->depth);
 	GpuErrorCheck(cudaMemcpy(deviceMat.getElements(), this->elements, this->width * this->height * this->depth * sizeof(T), cudaMemcpyHostToDevice));
diff -uarN 2015_kalantari_lbf/LBF/NeuralNetwork.cpp ../methods/2015_kalantari_lbf/LBF/NeuralNetwork.cpp
--- 2015_kalantari_lbf/LBF/NeuralNetwork.cpp	2015-05-20 17:09:18.000000000 -0700
+++ ../methods/2015_kalantari_lbf/LBF/NeuralNetwork.cpp	2019-09-11 11:26:25.572201673 -0700
@@ -1,5 +1,5 @@
-#include "NeuralNetwork.h"
-#include "Utilities.h"
+#include "LBF/NeuralNetwork.h"
+#include "LBF/Utilities.h"
 
 void AddBiasApplyActivation(FUNC func, Matrix<float>& A, Matrix<float>& B, bool isLastLayer);
 void FilterImage(float* filteredImg, float* alpha, float* variances, int halfBlock, int width, int height);
@@ -49,12 +49,11 @@
 	char buff[BUFFER_SIZE];
 	sprintf(buff, "%s/Weights.dat", inputFolder);
 	LoadNodeData(devWeights, hostWeights, buff);
-
 }
 
 NeuralNetwork::~NeuralNetwork(void)
 {
-
+	printf("deleting net params\n");
 	delete[] activationFuncsPerLayer;
 	delete[] devWeights;
 	delete[] hostWeights;
@@ -68,38 +67,68 @@
 	Matrix<float>* devAct = new Matrix<float>[numOfLayers];
 	Matrix<float> inputFeatures(width, height, featureLength);
 	Matrix<float> blockInvStd(width, height, NUM_OF_COLORS + NUM_OF_FEATURES);
+	// printf("  init: %d\n\n", inputFeatures.isCudaMat);
+	//
+	cudaDeviceSynchronize();
+
 	inputFeatures.setElements(featureData);
+	printf("  set elements done: %d\n\n", inputFeatures.isCudaMat);
+	cudaDeviceSynchronize();
+
 	blockInvStd.setElements(varData);
 	blockInvStd.setIsCudaMat(true);
 	inputFeatures.Reshape(width * height, featureLength);
+	printf("  reshape done: %d\n\n", inputFeatures.isCudaMat);
+	cudaDeviceSynchronize();
 
 	// Send secondary features to NN to get filter weights (Eq. 7)
 	FeedForward(inputFeatures, devAct);
+	printf("  feedforward done: %d\n\n", inputFeatures.isCudaMat);
+	cudaDeviceSynchronize();
 
 	// Filter image (Eq. 1)
 	Matrix<float> devFilteredImg(width * height, NUM_OF_COLORS);
 	devFilteredImg.AllocateData(true);
 	devFilteredImg.SetToZero();
 	FilterImage(devFilteredImg.getElements(), devAct[numOfLayers-1].getElements(), blockInvStd.getElements(), halfBlock, width, height);
+	printf("  filtering done: %d\n\n", inputFeatures.isCudaMat);
+	cudaDeviceSynchronize();
 
 	// Remove spikes (Sec. 4.3)
 	SpikeRemoval(devFilteredImg, height, width);
+	cudaDeviceSynchronize();
 
 	// Save raw output
 	char buff[BUFFER_SIZE];
-	sprintf(buff, "%s/%s_LBF_flt.exr", inputFolder, sceneName);
+	sprintf(buff, "%s/%s.exr", inputFolder, sceneName);
+	// sprintf(buff, "%s/%s_LBF_flt.exr", inputFolder, sceneName);
 	devFilteredImg.DeviceToHost();
 	devFilteredImg.Reshape(width, height, NUM_OF_COLORS);
 	devFilteredImg.saveToEXR(buff);
+	printf("  saving done\n\n");
+	cudaDeviceSynchronize();
 
 	// Cleanup
+	printf("cleanup\n");
+	printf("devAct:\n");
+	for (int i = 0; i < numOfLayers; ++i) {
+		printf("  isCuda %d? %d %d %d %d %p\n", i, devAct[i].isCudaMat,
+				devAct[i].getWidth(), devAct[i].getHeight(), devAct[i].getDepth(),
+				devAct[i].getElements());
+	}
 	delete[] devAct;
+	printf("\ndevFilter:\n");
 	devFilteredImg.~Matrix();
+	cudaDeviceSynchronize();
+	printf("\ninputFeatures:\n");
 	inputFeatures.~Matrix();
-	blockInvStd.~Matrix();
+	cudaDeviceSynchronize();
+
+	printf("\nblockInvStd:\n");
+	// blockInvStd.~Matrix();
 	CublasErrorCheck(cublasDestroy(handle));
 	GpuErrorCheck(cudaFreeArray(devSampleArray));
-
+	printf("cleanup done\n");
 }
 
 void NeuralNetwork::FeedForward(Matrix<float>& input, Matrix<float>* devAct)
diff -uarN 2015_kalantari_lbf/LBF/NeuralNetwork.h ../methods/2015_kalantari_lbf/LBF/NeuralNetwork.h
--- 2015_kalantari_lbf/LBF/NeuralNetwork.h	2015-04-15 12:12:20.000000000 -0700
+++ ../methods/2015_kalantari_lbf/LBF/NeuralNetwork.h	2019-09-11 11:26:25.572201673 -0700
@@ -1,9 +1,9 @@
 #ifndef NEURALNETWORK_H
 #define NEURALNETWORK_H
 
-#include "Matrix.h"
-#include "../core/timer.h"
-#include "Globals.h"
+#include "LBF/Matrix.h"
+#include "core/timer.h"
+#include "LBF/Globals.h"
 #include <cublas_v2.h>
 
 extern cudaArray* devSampleArray;
@@ -43,7 +43,6 @@
 
 	// Helper cublas function
 	void MatMultAB(cublasHandle_t handle, Matrix<float>& A, Matrix<float>& B, Matrix<float>& C);
-
 };
 
 
diff -uarN 2015_kalantari_lbf/LBF/Utilities.cpp ../methods/2015_kalantari_lbf/LBF/Utilities.cpp
--- 2015_kalantari_lbf/LBF/Utilities.cpp	2015-05-18 12:26:16.000000000 -0700
+++ ../methods/2015_kalantari_lbf/LBF/Utilities.cpp	2019-09-11 11:26:25.572201673 -0700
@@ -1,4 +1,4 @@
-#include "Utilities.h"
+#include "LBF/Utilities.h"
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
@@ -11,8 +11,9 @@
 
 FILE* OpenFile(char* fileName, char* type)
 {
-	FILE* fp;
-	fopen_s(&fp, fileName, type);
+	FILE* fp = fopen(fileName, type);
+	// FILE* fp;
+	// fopen_s(&fp, fileName, type);
 
 	if(!fp) 
 	{
@@ -57,7 +58,7 @@
 void CublasErrorCheck(cublasStatus_t err) 
 {
 	
-	if(err != cudaSuccess) 
+	if(err != CUBLAS_STATUS_SUCCESS) 
 	{
 		fprintf(stderr, "Cublas returned error code: %d, file %s, line(%d)\n", err, __FILE__, __LINE__);
 		getchar();
diff -uarN 2015_kalantari_lbf/LBF/Utilities.h ../methods/2015_kalantari_lbf/LBF/Utilities.h
--- 2015_kalantari_lbf/LBF/Utilities.h	2015-05-18 12:26:26.000000000 -0700
+++ ../methods/2015_kalantari_lbf/LBF/Utilities.h	2019-09-11 11:26:25.572201673 -0700
@@ -3,12 +3,13 @@
 
 template<class T> class Matrix;
 
+#include "LBF/Globals.h"
 #include <stdio.h>
 #include <cublas_v2.h>
-#include "Globals.h"
-#include "Matrix.h"
+// #include "LBF/Matrix.h"
 
-#define OPENEXR_DLL
+
+// #define OPENEXR_DLL
 #include <ImfRgbaFile.h>
 #include <ImfOutputFile.h>
 #include <ImfInputFile.h>
@@ -20,14 +21,14 @@
 #include <half.h>
 
 #include <iostream>
-#include <tchar.h>
+// #include <tchar.h>
 #include <algorithm>
 
 FILE* OpenFile(char* fileName, char* type);
 void PrintError(cudaError_t err, char* file, int line);
 void CublasErrorCheck(cublasStatus_t err);
 void PrintAvailableMemory();
-void WriteEXRImage(const std::string &name, float *pixels, float *alpha, int xRes, int yRes, int totalXRes, int totalYRes, int xOffset, int yOffset);
+static void WriteEXRImage(const std::string &name, float *pixels, float *alpha, int xRes, int yRes, int totalXRes, int totalYRes, int xOffset, int yOffset);
 void WriteEXRFile(char* fileName, int xRes, int yRes, float* input);
 
-#endif
\ No newline at end of file
+#endif
diff -uarN 2015_kalantari_lbf/main/pbrt.cpp ../methods/2015_kalantari_lbf/main/pbrt.cpp
--- 2015_kalantari_lbf/main/pbrt.cpp	2015-05-14 12:07:28.000000000 -0700
+++ ../methods/2015_kalantari_lbf/main/pbrt.cpp	2019-09-11 11:26:25.576201709 -0700
@@ -46,7 +46,7 @@
 #include "parser.h"
 #include "parallel.h"
 #include "../LBF/Globals.h"
-#include "../core/Timer.h"
+#include "../core/timer.h"
 
 extern char sceneName[BUFFER_SIZE]; 
 extern int pbrtSamplesPerPixel; 
@@ -121,28 +121,28 @@
 	float runtime = timer.Time();
 	
 	char tmpFileName[1000];
-	_splitpath(filenames[0].c_str(), NULL, NULL, tmpFileName, NULL);
-	sprintf(tmpFileName, "%s_timing.txt", sceneName);
+	// _splitpath(filenames[0].c_str(), NULL, NULL, tmpFileName, NULL);\
+	// sprintf(tmpFileName, "%s_timing.txt", sceneName);\
 
-	FILE* fp;
-	fopen_s(&fp, tmpFileName, "at");
+	// FILE* fp;\
+	// fopen_s(&fp, tmpFileName, "at");\
 
-	if(!fp)
-	{
-		fprintf(stderr, "Could not open file %s\n", tmpFileName);
-		getchar();
-		exit(-1);
-	}
+	// if(!fp)\
+	// {\
+		// fprintf(stderr, "Could not open file %s\n", tmpFileName);\
+	// 	getchar();\
+	// 	exit(-1);\
+	// }\
 
-	fprintf(fp, "Total Time: %f sec", runtime);
-	fclose(fp);
+	// fprintf(fp, "Total Time: %f sec", runtime);\
+	// fclose(fp);\
 
 	printf("Total Time: %f\n", runtime);
 
 	///////////////////////////
     
 	// Dump memory leaks
-	_CrtDumpMemoryLeaks();
+	// _CrtDumpMemoryLeaks();\
 
 	return 0;
 }
diff -uarN 2015_kalantari_lbf/Makefile ../methods/2015_kalantari_lbf/Makefile
--- 2015_kalantari_lbf/Makefile	2013-07-09 07:53:44.000000000 -0700
+++ ../methods/2015_kalantari_lbf/Makefile	2019-09-11 11:26:25.572201673 -0700
@@ -5,12 +5,12 @@
 # common locations for the OpenEXR libraries; may need to be updated
 # for unusual installation locations
 HAVE_EXR=1
-EXR_INCLUDES=-I/usr/local/include/OpenEXR -I/usr/include/OpenEXR -I/opt/local/include/OpenEXR 
-EXR_LIBDIR=-L/usr/local/lib -L/opt/local/lib
+EXR_INCLUDES=-I/usr/local/include/OpenEXR -I/usr/include/OpenEXR #-I/opt/local/include/OpenEXR 
+EXR_LIBDIR=-L/usr/local/lib #-L/opt/local/lib
 
 HAVE_LIBTIFF=0
 TIFF_INCLUDES=-I/usr/local/include -I/opt/local/include
-TIFF_LIBDIR=-L/usr/local/lib -L/opt/local/lib
+TIFF_LIBDIR=-L/usr/local/lib #-L/opt/local/lib
 
 HAVE_DTRACE=0
 
@@ -21,7 +21,7 @@
 #MARCH=-m32 -msse2 -mfpmath=sse
 
 # 64 bit
-MARCH=-m64
+MARCH=-m64 -march=native
 
 # change this to -g3 for debug builds
 OPT=-O2
@@ -60,23 +60,28 @@
 endif
 
 CC=gcc
-CXX=g++
+CXX=g++ -fopenmp -std=gnu++11 -fpermissive
 LD=$(CXX) $(OPT) $(MARCH)
-INCLUDE=-I. -Icore $(EXR_INCLUDES) $(TIFF_INCLUDES)
+INCLUDE=-I. -Icore $(EXR_INCLUDES) $(TIFF_INCLUDES) -I/usr/local/cuda/include
 WARN=-Wall
 CWD=$(shell pwd)
 CXXFLAGS=$(OPT) $(MARCH) $(INCLUDE) $(WARN) $(DEFS)
+NVCC=nvcc -std=c++11 $(OPT) $(INCLUDE) $(DEFS)
 CCFLAGS=$(CXXFLAGS)
-LIBS=$(LEXLIB) $(EXR_LIBDIR) $(EXRLIBS) -lm 
+LIBS=$(LEXLIB) $(EXR_LIBDIR) $(EXRLIBS) -lm -L/usr/local/cuda/lib64 -lcudart -lcublas
 
 LIB_CSRCS=core/targa.c
 LIB_CXXSRCS  = $(wildcard core/*.cpp) core/pbrtlex.cpp core/pbrtparse.cpp
 LIB_CXXSRCS += $(wildcard accelerators/*.cpp cameras/*.cpp film/*.cpp filters/*.cpp )
 LIB_CXXSRCS += $(wildcard integrators/*.cpp lights/*.cpp materials/*.cpp renderers/*.cpp )
 LIB_CXXSRCS += $(wildcard samplers/*.cpp shapes/*.cpp textures/*.cpp volumes/*.cpp)
+LIB_CXXSRCS += $(wildcard SampleWriter/*.cpp)
+LIB_CXXSRCS += $(wildcard LBF/*.cpp)
+LIB_CUDASRCS = $(wildcard LBF/*.cu)
 
 LIBOBJS  = $(addprefix objs/, $(subst /,_,$(LIB_CSRCS:.c=.o)))
 LIBOBJS += $(addprefix objs/, $(subst /,_,$(LIB_CXXSRCS:.cpp=.o)))
+LIBOBJS += $(addprefix objs/, $(subst /,_,$(LIB_CUDASRCS:.cu=.o)))
 
 HEADERS = $(wildcard */*.h)
 
@@ -103,6 +108,18 @@
 	@echo "Building the core rendering library (libpbrt.a)"
 	@ar rcs $@ $(LIBOBJS)
 
+objs/SampleWriter_%.o: SampleWriter/%.cpp
+	@echo "Building object $@"
+	@$(CXX) $(CXXFLAGS) -o $@ -c $<
+
+objs/LBF_CudaFeatureFuncs.o: LBF/CudaFeatureFuncs.cu
+	@echo "Building object $@"
+	@$(NVCC) -o $@ -c $<
+
+objs/LBF_%.o: LBF/%.cpp
+	@echo "Building object $@"
+	@$(CXX) $(CXXFLAGS) -o $@ -c $<
+
 objs/accelerators_%.o: accelerators/%.cpp
 	@echo "Building object $@"
 	@$(CXX) $(CXXFLAGS) -o $@ -c $<
diff -uarN 2015_kalantari_lbf/renderers/metropolis.cpp ../methods/2015_kalantari_lbf/renderers/metropolis.cpp
--- 2015_kalantari_lbf/renderers/metropolis.cpp	2014-04-22 18:43:46.000000000 -0700
+++ ../methods/2015_kalantari_lbf/renderers/metropolis.cpp	2019-09-11 11:26:25.576201709 -0700
@@ -733,14 +733,14 @@
         // Splat current and proposed samples to _Film_
         PBRT_MLT_STARTED_SAMPLE_SPLAT();
         if (I[current] > 0.f) {
-            if (!isinf(1.f / I[current])) {
+            if (!std::isinf(1.f / I[current])) {
             Spectrum contrib =  (b / nPixelSamples) * L[current] / I[current];
             camera->film->Splat(samples[current].cameraSample,
                                 (1.f - a) * contrib);
         }
         }
         if (I[proposed] > 0.f) {
-            if (!isinf(1.f / I[proposed])) {
+            if (!std::isinf(1.f / I[proposed])) {
             Spectrum contrib =  (b / nPixelSamples) * L[proposed] / I[proposed];
             camera->film->Splat(samples[proposed].cameraSample,
                                 a * contrib);
diff -uarN 2015_kalantari_lbf/renderers/samplerrenderer.cpp ../methods/2015_kalantari_lbf/renderers/samplerrenderer.cpp
--- 2015_kalantari_lbf/renderers/samplerrenderer.cpp	2015-05-20 14:34:04.000000000 -0700
+++ ../methods/2015_kalantari_lbf/renderers/samplerrenderer.cpp	2019-09-11 11:26:25.576201709 -0700
@@ -171,7 +171,7 @@
                       "for image sample.  Setting to black.", Ls[i].y());
                 Ls[i] = Spectrum(0.f);
             }
-            else if (isinf(Ls[i].y())) {
+            else if (std::isinf(Ls[i].y())) {
                 Error("Infinite luminance value returned"
                       "for image sample.  Setting to black.");
                 Ls[i] = Spectrum(0.f);
diff -uarN 2015_kalantari_lbf/SampleWriter/CImg.h ../methods/2015_kalantari_lbf/SampleWriter/CImg.h
--- 2015_kalantari_lbf/SampleWriter/CImg.h	2013-07-04 17:26:50.000000000 -0700
+++ ../methods/2015_kalantari_lbf/SampleWriter/CImg.h	2019-09-11 11:26:25.572201673 -0700
@@ -181,9 +181,9 @@
 #define cimg_display 0
 #elif cimg_OS==1
 #if defined(__MACOSX__) || defined(__APPLE__)
-#define cimg_display 1
+#define cimg_display 0
 #else
-#define cimg_display 1
+#define cimg_display 0
 #endif
 #elif cimg_OS==2
 #define cimg_display 2
diff -uarN 2015_kalantari_lbf/SampleWriter/Globals.h ../methods/2015_kalantari_lbf/SampleWriter/Globals.h
--- 2015_kalantari_lbf/SampleWriter/Globals.h	2015-04-13 14:16:44.000000000 -0700
+++ ../methods/2015_kalantari_lbf/SampleWriter/Globals.h	2019-09-11 11:26:25.572201673 -0700
@@ -9,7 +9,8 @@
 #define SAVE_SAMPLES 1
 
 // Use as a static class in Pbrt
-#define SAMPLER_API __declspec(dllexport)
+// #define SAMPLER_API __declspec(dllexport)
+#define SAMPLER_API
 class SAMPLER_API SampleWriter;
 
 // To avoid samples on pixel boundaries
@@ -38,4 +39,4 @@
 
 }; 
 
-#endif
\ No newline at end of file
+#endif
diff -uarN 2015_kalantari_lbf/SampleWriter/SampleWriter.cpp ../methods/2015_kalantari_lbf/SampleWriter/SampleWriter.cpp
--- 2015_kalantari_lbf/SampleWriter/SampleWriter.cpp	2015-05-21 11:48:36.000000000 -0700
+++ ../methods/2015_kalantari_lbf/SampleWriter/SampleWriter.cpp	2019-09-11 11:26:25.572201673 -0700
@@ -1,4 +1,4 @@
-#include "SampleWriter.h"
+#include "SampleWriter/SampleWriter.h"
 
 int SampleWriter::numOfBuffers;
 int* SampleWriter::featureInd;
@@ -115,8 +115,9 @@
 	timer.Stop();
 	char tmpFileName[1000];
 	sprintf(tmpFileName, "%s\\%s_timing.txt", inputFolder, sceneName);
-	FILE* fp;
-	fopen_s(&fp, tmpFileName, "wt");
+	// FILE* fp;
+	FILE *fp = fopen(tmpFileName, "wt");
+	// fopen_s(&fp, tmpFileName, "wt");
 
 	if(!fp) {
 		fprintf(stderr, "Could not open file %s\n", tmpFileName);
diff -uarN 2015_kalantari_lbf/SampleWriter/SampleWriter.h ../methods/2015_kalantari_lbf/SampleWriter/SampleWriter.h
--- 2015_kalantari_lbf/SampleWriter/SampleWriter.h	2015-05-18 14:48:50.000000000 -0700
+++ ../methods/2015_kalantari_lbf/SampleWriter/SampleWriter.h	2019-09-11 11:26:25.572201673 -0700
@@ -1,10 +1,10 @@
 #ifndef	SAMPLEWRITER_H_INCLUDED
 #define SAMPLEWRITER_H_INCLUDED
 
-#include "CImg.h"
-#include "Globals.h"
-#include "../core/timer.h"
-#include "../LBF/Globals.h"
+#include "SampleWriter/CImg.h"
+#include "SampleWriter/Globals.h"
+#include "core/timer.h"
+#include "LBF/Globals.h"
 
 using namespace cimg_library;
 
@@ -57,4 +57,4 @@
 
 };
 
-#endif
\ No newline at end of file
+#endif
diff -uarN 2015_kalantari_lbf/shapes/hyperboloid.cpp ../methods/2015_kalantari_lbf/shapes/hyperboloid.cpp
--- 2015_kalantari_lbf/shapes/hyperboloid.cpp	2013-07-09 07:53:46.000000000 -0700
+++ ../methods/2015_kalantari_lbf/shapes/hyperboloid.cpp	2019-09-11 11:26:25.580201745 -0700
@@ -58,7 +58,7 @@
         a = (1.f/xy1 - (pp.z*pp.z)/(xy1*p2.z*p2.z)) /
             (1 - (xy2*pp.z*pp.z)/(xy1*p2.z*p2.z));
         c = (a * xy2 - 1) / (p2.z*p2.z);
-    } while (isinf(a) || isnan(a));
+    } while (std::isinf(a) || std::isnan(a));
 }
 
 
diff -uarN 2015_kalantari_lbf/tools/bsdftest.cpp ../methods/2015_kalantari_lbf/tools/bsdftest.cpp
--- 2015_kalantari_lbf/tools/bsdftest.cpp	2013-07-09 07:53:46.000000000 -0700
+++ ../methods/2015_kalantari_lbf/tools/bsdftest.cpp	2019-09-11 11:26:25.580201745 -0700
@@ -214,7 +214,7 @@
 
                 if (!validSample) {
                     outsideSamples++;
-                } else if (pdf == 0.f || isnan(pdf) || redF < 0 || isnan(redF)) {
+                } else if (pdf == 0.f || std::isnan(pdf) || redF < 0 || std::isnan(redF)) {
                     if (badSamples == warningTarget) {
                         fprintf(stderr, "warning %d, bad sample %d! "
                             "pdf: %.3f, redF: %.3f\n",
